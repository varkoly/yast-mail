/**
 * File:
 *   include/mail/ui.ycp
 *
 * Package:
 *   Configuration of mail
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "mail";

import "Wizard";
import "Progress";
import "Mode";
import "Mail";

include "ui/common_popups.ycp";
include "ui/common_messages.ycp";
include "wizard/sequencer.ycp";
include "network/dns.ycp";
include "network/ip.ycp";
include "require.ycp";

include "mail/helps.ycp";

/**
 * A replacement for the Next button: "Finish", `next
 */
global term finish_button = `PushButton (`id (`next), `opt (`default), FinishButtonLabel());

/**
 * A Wizard Sequencer helper
 * @return	`next
 */
global define symbol JustNext () ``{
    return `next;
}

global map dialogs = $[
    "read"	: [ ``( ReadDialog () ), true ],
    "confirm"	: [ ``( ConfirmDialog () ), true],
    "write"	: [ ``( WriteDialog () ), true ],

    "mta":		``( MtaSelectionDialog () ),

    "connection_type":	``( ConnectionTypeDialog () ),
    "outgoing":		``( OutgoingDialog () ),
    "masquerading":	``( MasqueradingDialog () ),
    "dialup?":		[ ``( DialupOnly () ), true ],
    "downloading":	``( DownloadingDialog () ),
    "aliases":		``( AliasesDialog () ),
    "virtual":		``( VirtualDialog () ),
    "common-next":	[ ``( JustNext () ), true ],
    ];

global map common_sequence = $[
    //"ws_start" : must be defined in an overriding sequence
    "connection_type" :
    $[
	`abort	: `abort,
	`next	: "outgoing",
	`aliases	: "aliases",
	`virtual	: "virtual",
	`none	: "common-next",
	],
    "aliases" :
    $[
	`abort	: `abort,
	`next	: "connection_type",
	],
    "virtual" :
    $[
	`abort	: `abort,
	`next	: "connection_type",
	],
    "outgoing" :
    $[
	`abort	: `abort,
	`next	: "dialup?",
	`masqdetail : "masquerading",
	],
    "masquerading" :
    $[
	`abort	: `abort,
	`next	: "outgoing",
	],
    "dialup?" :
    $[
	`yes	: "downloading",
	`no	: "common-next",
	],
    "downloading" :
    $[
	`abort	: `abort,
	`next	: "common-next",
	],
    "common-next" :
    $[
	`next	: `next,
	],
    ];

/**
 * Whole configuration of mail
 * @return `back, `abort or `next
 */
global define symbol MailSequence () ``{
    map sequence = $[
	"ws_start" : "read",
	"read" :
	$[
	    `abort	: `abort,
	    `next	: "connection_type",
	    ],

	// common_sequence here

	// override
	"common-next" :
	$[
	    `next	: "confirm",
	    ],
	"confirm" :
	$[
	    `next	: "write"
	    ],
	"write" : $[
	    `abort	: `abort,
	    `next	: `next
	    ]
	];

    // Translators: dialog caption
    string caption = _("Mail configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // the second map must override the first!
    sequence = union (common_sequence, sequence);
    any ret = WizardSequencer (dialogs, sequence);

    UI::CloseDialog ();
    return ret;
}

/**
 * Whole configuration of mail but without reading and writing.
 * MTA is selected first.
 * For use with autoinstallation.
 * @return `back, `abort or `next
 */
global define symbol MailAutoSequence () ``{
    map sequence = $[
	"ws_start":	"mta",
	"mta":
	$[
	    `abort	: `abort,
	    `next	: "connection_type",
	    ],

	// common_sequence here
	];

    // Translators: dialog caption
    string caption = _("Mail configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // the second map must override the first!
    sequence = union (common_sequence, sequence);
    any ret = WizardSequencer (dialogs, sequence);

    UI::CloseDialog ();
    return ret;
}


/**
 * Read settings dialog
 * @return `abort or `next
 */
global define symbol ReadDialog () ``{
    // Set help text
    Wizard::RestoreHelp (ReadDialogHelp ());

    // A callback function for abort
    block callback = ``{
	return UI::PollInput () == `abort;
    };

    // Read the configuration
    boolean was_ok = Mail::Read ( callback );

    // TODO FIXME possibly handle the abort
    if (was_ok)
    {
	if (! Mail::CreateConfig ())
	{
	    string setting = "MAIL_CREATE_CONFIG";
	    // Translators: continue/cancel dialog
	    // %1 is a sysconfig variable name
	    was_ok = UI::ContinueCancelPopup (sformat (_("The setting %1 is turned off. You have
probably modified the configuration files directly.
If you continue, it will be turned on and
SuSEconfig will overwrite manual changes.
"), setting));
	}
    }

    return ( was_ok? `next : `abort );
}

/**
 * Confirmation dialog before saving and installing needed packages
 * @return `back or `next
 */
global define symbol ConfirmDialog () ``{
    string message1 = _("The configuration will be written now.\n");
    string message2 = Mail::ProbePackages ();
    return UI::ContinueCancelPopup (message1 + message2) ? `next : `back;
}

/**
 * Write settings dialog
 * @return `abort or `next
 */
global define symbol WriteDialog () ``{
    // Install packages if needed.
    // Cannot do it in Write, autoinstall does it differently.
    if (size (Mail::install_packages) > 0 || size (Mail::remove_packages) > 0)
    {
	// require.ycp
	DoInstallAndRemove (Mail::install_packages, Mail::remove_packages);
    }

    // Set help text
    Wizard::RestoreHelp (WriteDialogHelp ());

    // A callback function for abort
    block callback = ``{
	return UI::PollInput () == `abort;
    };

    // Read the configuration
    boolean was_ok = Mail::Write ( callback, false );

    // TODO FIXME possibly handle the abort

    return ( was_ok? `next : `abort );
}

/**
 * MTA selection dialog
 * (only for autoinstallation, otherwise probed in Mail::Read)
 * @return `abort or `next
 */
global define symbol MtaSelectionDialog () ``{
    symbol mta = Mail::mta;
    // for now. TODO: disable Next if none selected
    if (mta != `sendmail && mta != `postfix)
    {
	mta = `sendmail;
    }

    // Translators: dialog caption
    // Mailer: Sendmail or Postfix
    string caption = _("Mail transfer agent");
    term contents =
	`Frame (
	    // Translators: frame label
	    // Mailer: Sendmail or Postfix
	    _("Mail transfer agent"),
	    `RadioButtonGroup (
		`id (`mtag),
		`HSquash (
		    `VBox (
			`VSpacing (0.2),
			// MTA name does not need translation
			`Left (`RadioButton (`id (`sendmail), `opt(`autoShortcut), "Sendmail", mta == `sendmail)),
			// MTA name does not need translation
			`Left (`RadioButton (`id (`postfix), `opt(`autoShortcut), "Postfix", mta == `postfix)),
			`VSpacing (0.2)
			)
		    )
		)
	    );

    Wizard::SetContentsButtons (caption, contents, MtaSelectionDialogHelp (), BackButtonLabel (), NextButtonLabel ());

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	if (ret == `back || ret == `next ||
	    (ret == `abort && UI::ReallyAbortPopup (Mail::touched)))
	{
	    break;
	}
    }

    if (ret == `next)
    {
	mta = UI::QueryWidget (`id (`mtag), `CurrentButton);
	Mail::Touch (Mail::mta != mta);
	Mail::mta = mta;
    }
    return ret;
}

/* ---------------------------------------------------------------- */

/**
 * @param data	a list of structs
 * @param keys	which members to put in the table
 * @return	an item list
 */
global define list(term) makeItems (list(map) data, list(string) keys) ``{
    integer i = 0;
    return maplist (`d, data, ``{
	term t = `item (`id (i));
	i = i + 1;
	foreach (`k, keys, ``{
	    t = add (t, lookup (d, k, ""));
	});
	return t;
    });
}

global boolean edit_touched = false;

/**
 * A generic handler for editing tables.
 * The current item of table_widget
 * makeItems (new_data, keys) is used to fill table_widget
 * @param action	`add, `edit or `delete
 * @param data		the data edited using the table
 * @param keys		keys of respective columns
 * @param editEntry	a function to edit an entry:
 *			gets the current entry and list of othe entries as parameters
 * @param table_widget	id of the table (usually a symbol)
 * @return		the edited data
 */
global define list(map) EditTable (symbol action,
				   list(map) data,
				   list(string) keys,
				   term editEntry,
				   any table_widget) ``{
    list(map) new_data = nil;
    integer entryno = UI::QueryWidget (`id (table_widget), `CurrentItem);
    boolean touched = false;
    if (action == `add)
    {
	editEntry = add (editEntry, $[]);
	editEntry = add (editEntry, data);
	map entry = eval (editEntry);
	if (size (entry) > 0)
	{
	    new_data = add (data, entry);
	    touched = true;
	}
	else
	{
	    new_data = data;
	}
    }
    else if (action == `edit)
    {
	// edit known fields, preserve unknown fields
	map old_entry = select (data, entryno, $[]);
	editEntry = add (editEntry, old_entry);
	editEntry = add (editEntry, remove (data, entryno));
	map entry = eval (editEntry);
	if (size (entry) > 0)
	{
	    integer i = 0;
	    new_data = maplist (`e, data, ``{
		i = i + 1;
		return (i - 1 == entryno)? union (old_entry, entry): e;
	    });
	    touched = true;
	}
	else
	{
	    new_data = data;
	}
    }
    else if (action == `delete)
    {
	new_data = remove (data, entryno);
	touched = true;
    }
    else
    {
	y2error ("Unknown EditTable action %1.", action);
	new_data = data; // be nice
    }

    if (touched)
    {
	UI::ChangeWidget (`id (table_widget), `Items, makeItems (new_data, keys));
	edit_touched = true;
    }
    return new_data;
}

/* ---------------------------------------------------------------- */

/**
 * D1
 * @return `back, `abort, `next or `none
 */
global define symbol ConnectionTypeDialog () ``{
    symbol ct = Mail::connection_type;
    boolean amavis_allowed = Mail::amavis_allowed;
    boolean amavis = Mail::use_amavis;

    // Translators: dialog caption
    string caption = _("General mail settings");
    term contents =
	`Frame (
	    // Translators: frame label
	    _("Connection type"),
	    `RadioButtonGroup (
		`id (`ctg),
		`HSquash (
		    `VBox (
			`VSpacing (0.2),
			// Translators: radio button label
			`Left (`RadioButton (`id (`permanent), `opt (`notify), _("&Permanent"), ct == `permanent)),
			// Translators: radio button label
			`Left (`RadioButton (`id (`dialup), `opt (`notify), _("&Dial-up"), ct == `dialup)),
			// Translators: radio button label
			`Left (`RadioButton (`id (`none), `opt (`notify), _("No &connection"), ct == `none)),
/*
			`VSpacing (0.5),
			`Left (`RadioButton (`id (`dont), _("Do not configure"), false)),
*/
			`VSpacing (0.2)
			)
		    )
		)
	    );

    contents = `VBox (
	contents,
	`VSpacing (1),
	// Translators: button
	`PushButton (`id (`aliases), _("&Aliases ...")),
	// Translators: button
	`PushButton (`id (`virtual), _("&Virtual domains ..."))
	);

    if (amavis_allowed)
    {
	contents = add (contents, `VSpacing (1));
	// Translators: check box label
	contents = add (contents, `CheckBox (`id (`amavis), _("&Enable virus scanning (AMaViS)"), amavis));
    }
    else
    {
	contents = add (contents, `Empty (`id (`amavis)));
    }

    Wizard::SetContentsButtons (caption, contents, ConnectionTypeDialogHelp (amavis_allowed), BackButtonLabel (), NextButtonLabel ());

    any ret = nil;
    while (true)
    {
	ct = UI::QueryWidget (`id (`ctg), `CurrentButton);
	if (ct == `permanent || ct == `dialup)
	{
	    UI::ChangeWidget (`id (`next), `Label, NextButtonLabel());
	    //argh, slow
	    //Wizard::RestoreNextButton ();
	    UI::ChangeWidget (`id (`amavis), `Enabled, true);
	    UI::ChangeWidget (`id (`aliases), `Enabled, true);
	    UI::ChangeWidget (`id (`virtual), `Enabled, true);
	}
	else if (ct == `none)
	{
	    UI::ChangeWidget (`id (`next), `Label, FinishButtonLabel());
	    //argh, slow
	    //Wizard::ReplaceNextButton (finish_button);
	    UI::ChangeWidget (`id (`amavis), `Value, false);
	    UI::ChangeWidget (`id (`amavis), `Enabled, false);
	    UI::ChangeWidget (`id (`aliases), `Enabled, false);
	    UI::ChangeWidget (`id (`virtual), `Enabled, false);
	}

	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	if (ret == `back || ret == `next || ret == `aliases || ret == `virtual ||
	    (ret == `abort && UI::ReallyAbortPopup (Mail::touched)))
	{
	    break;
	}
    }

    if (ret == `next || ret == `aliases || ret == `virtual)
    {
	ct = UI::QueryWidget (`id (`ctg), `CurrentButton);
	Mail::Touch (Mail::connection_type != ct);
	Mail::connection_type = ct;

	amavis = amavis_allowed && UI::QueryWidget (`id (`amavis), `Value);
	Mail::Touch (Mail::use_amavis != amavis);
	Mail::use_amavis = amavis;

	ret = (ct == `none)? `none: ret;
    }
    return ret;
}

/**
 * Formats a list for a TextEntry, separating the elements by ", "
 * @param alist	a list
 * @return	a string
 */
global define string listToString (list(string) alist) ``{
    return mergestring (alist, ", ");
}

/**
 * Splits a TextEntry string into a list of strings
 * separated by spaces, commas or semicolons.
 * Empty strings are removed.
 * @param astring	a string
 * @return		a list of strings
 */
global define list(string) stringToList (string astring) ``{
    list(string) alist = splitstring (astring, " ,;");
    return filter (`s, alist, ``(s != ""));
}

/**
 * D2
 * @return `back, `abort, `next or `masqdetail
 */
global define symbol OutgoingDialog () ``{
    string ld = listToString (Mail::local_domains);
    list(string) lld = [];
    // when validating: may be enclosed in brackets (prevents mx lookups)
    string oms = Mail::outgoing_mail_server;
    string fh = Mail::from_header;

    // Translators: dialog caption
    string caption = _("Outgoing mail");
    term contents =
	`VBox (
	    `VSpacing (0.2),
	    // Translators: text entry label
	    `TextEntry (`id (`local), _("&Domains for locally delivered mail"), ld),
	    `VSpacing (0.5),
	    // Translators: text entry label
	    `TextEntry (`id (`relay), _("&Outgoing mail server"), oms),
	    `VSpacing (0.5),
	    // Translators: text entry label
	    `TextEntry (`id (`from), _("Do&main for the 'From' header"), fh),
	    // Translators: button
	    `PushButton (`id (`masqdetail), _("Detailed &address rewriting ...")),
	    `VSpacing (0.2)
	    );

    Wizard::SetContentsButtons (
	caption, contents, OutgoingDialogHelp (), BackButtonLabel (),
	(Mail::connection_type == `dialup) ?
	NextButtonLabel () : FinishButtonLabel ());

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	if (ret == `back ||
	    (ret == `abort && UI::ReallyAbortPopup (Mail::touched)))
	{
	    break;
	}
	else if (ret == `next || ret == `masqdetail)
	{
	    // input validation
	    // For consistency, all querywidgets are done here

	    ld = UI::QueryWidget (`id (`local), `Value);
	    lld = stringToList(ld);
	    oms = UI::QueryWidget (`id (`relay), `Value);
	    // watch this: "[", no brackets, "]"
	    string oms_no_brackets = regexpmatch (oms, "[[][^][]*[]]") ?
		regexpsub (oms, ".(.*).", "\\1") : oms;
	    fh = UI::QueryWidget (`id (`from), `Value);

	    if (find (string s, lld, ``(! check_domainname (s))) != nil)
	    {
		UI::SetFocus (`id (`local));
		// Translators: error popup
		// Already in Translation Memory
		string msg = _("The domain name is incorrect");
		// TODO: describe a valid domain name
		UI::ErrorPopup (msg);
	    }
	    else if (oms_no_brackets != "" &&
		     ! check_domainname (oms_no_brackets) &&
		     ! check_ip4 (oms_no_brackets))
	    {
		UI::SetFocus (`id (`relay));
		// Translators: error popup
		// Already in Translation Memory
		string msg = _("The host name is incorrect");
		// TODO: describe a valid host specification
		// (a host name or IP)
		UI::ErrorPopup (msg);
	    }
	    else if (fh != "" && ! check_domainname (fh))
	    {
		UI::SetFocus (`id (`from));
		// Translators: error popup
		// Already in Translation Memory
		string msg = _("The domain name is incorrect");
		// TODO: describe a valid domain name
		UI::ErrorPopup (msg);
	    }
	    else
	    {
		// all checks OK, break the input loop
		break;
	    }
	}
    }

    if (ret == `next || ret == `masqdetail)
    {
	// all querywidgets are already done by the validation part
	Mail::Touch (Mail::local_domains != lld);
	Mail::local_domains = lld;

	Mail::Touch (Mail::outgoing_mail_server != oms);
	Mail::outgoing_mail_server = oms;

	Mail::Touch (Mail::from_header != fh);
	Mail::from_header = fh;
    }
    return ret;
}

/**
 * D2.1
 * @return `back, `abort or `next
 */
global define symbol MasqueradingDialog () ``{

    string ld = listToString (Mail::local_domains);
    string mod = listToString (Mail::masquerade_other_domains);
    list(string) lmod = [];
    list(map) mu = Mail::masquerade_users;

    // Translators: dialog caption
    string caption = _("Detailed masquerading");
    term contents =
	`VBox (
	    `VSpacing (0.2),
	    `RadioButtonGroup (
		`id (`mdg),
		`VBox (
		    `VSpacing (0.2),
		    `Left (`RadioButton (
			       `id (`masqlocal),
			       // Translators: radio button label
			       sformat (_("Masquerade &local domains (%1)"), ld),
			       mod == "")),
//		    `HBox (
//			`HSpacing (2),
//			`TextEntry (`id (`masqdomains), `opt (`disabled), _("That is"), ld)
////			`Left (`Label (`opt (`outputField, `hstretch), ld))
//			),
		    // Translators: radio button label
		    `Left (`RadioButton (`id (`masqothers), _("Ma&squerade other domains"), mod != "")),
		    `HBox (
			`HSpacing (2),
			// Translators: text entry label
			`TextEntry (`id (`masqdomains), `opt (`notify), _("Do&mains to masquerade"), mod)
			)
		    )
		),

	    `VSpacing (1),

	    `Table (
		`id (`tab),
		`opt (`notify, `immediate),
		// Translators: table column headings
		`header (_("Local user"), _("Display as")),
		makeItems (mu, ["user", "address"])
		),
/*
	    `HBox (
		`HWeight (1, `ComboBox (`id (`user), `opt (`editable), _("Local user"),
					["holly", "jane", "tarzan"])),
		`HWeight (2, `TextEntry (`id (`address), _("Display as"), "holly@red.dwarf"))
		),
*/
	    `HBox(
		// Translators: button
		`PushButton(`id(`add), _("A&dd")),
		// Translators: button
		`PushButton(`id(`edit), _("&Edit")),
		// Translators: button
		`PushButton(`id(`delete), _("Dele&te"))
		),
	    `VSpacing (1)
	    );

    Wizard::SetContentsButtons (caption, contents, MasqueradingDialogHelp (), BackButtonLabel (), OKButtonLabel ());

    any ret = nil;
    edit_touched = false;
    while (true)
    {
	boolean any_items = UI::QueryWidget (`id (`tab), `CurrentItem) != nil;
	UI::ChangeWidget (`id (`edit), `Enabled, any_items);
	UI::ChangeWidget (`id (`delete), `Enabled, any_items);

	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	if (ret == `masqdomains)
	{
	    UI::ChangeWidget (`id (`mdg), `CurrentButton, `masqothers);
	}
	else if (contains ([`add, `edit, `delete], ret))
	{
	    mu = EditTable(ret, mu, ["user", "address"], ``(MasqueradeUserPopup ()), `tab);
	}
	else if ((ret == `abort
		  && UI::ReallyAbortPopup (Mail::touched || edit_touched))
		 || ret == `back)
	{
	    break;
	}
	else if (ret == `next)
	{
	    // Input validation
	    // For consistency, all querywidgets are done here.
	    // The table contents is maintained and validated
	    // at the EditTable call.

	    symbol rb = UI::QueryWidget (`id (`mdg), `CurrentButton);
	    if (rb == `masqothers)
	    {
		mod = UI::QueryWidget (`id (`masqdomains), `Value);
		lmod = stringToList (mod);
	    }
	    else
	    {
		lmod = [];
	    }

	    if (find (string s, lmod, ``(! check_domainname (s))) != nil)
	    {
		UI::SetFocus (`id (`masqdomains));
		// Translators: error popup
		// Already in Translation Memory
		string msg = _("The domain name is incorrect");
		// TODO: describe a valid domain name
		UI::ErrorPopup (msg);
	    }
	    else
	    {
		// all checks OK, break the input loop
		break;
	    }
	}
    }

    if (ret == `next)
    {
	// all querywidgets are already done by the validation part
	Mail::Touch (Mail::masquerade_other_domains != lmod);
	Mail::masquerade_other_domains = lmod;

	Mail::Touch (Mail::masquerade_users != mu);
	Mail::masquerade_users = mu;
    }
    return ret;
}

/**
 * (taken from y2c_users ui.ycp)
 * @param username a string
 * @return Whether a string contains only valid user name characters
 */
global define boolean check_username (string username) ``{
//DUH, auth_dialogs.ycp, users.ycp and Users.ycp have conflicing definitions!
    string valid_logname_chars  = "0123456789abcdefghijklmnopqrstuvwxyz-_";

    string firstchar = substring (username, 0, 1);
    return username != "" &&
	( (firstchar >= "a" && firstchar <= "z" ) || firstchar == "_"  ) &&
	findfirstnotof (username, valid_logname_chars) == nil;
}

/**
 * (taken from y2c_users ui.ycp)
 * @return Describe a valid username
 */
global define string valid_username () ``{
    // There is a check whether the information from the UI is
    // correct and complete.  The login name may contain only
    // certain characters and must begin with a letter.
    // Already in Translation Memory
    return _("The user login may contain only
lower case letters, digits, \"-\" and \"_\"
and must begin with a letter or \"_\".
Please try again.
");
}

/**
 * See RFC 2822, 3.4
 * But for now, nonempty, no-spaces.
 * @param address an address to check
 * @return valid?
 */
global define boolean check_mail_local_part (string address) ``{
    return address != "" && findfirstof (address, " ") == nil;
}

/**
 * See RFC 2822, 3.4
 * But for now, no-spaces@valid_domainname
 * @param address an address to check
 * @return valid?
 */
global define boolean check_mail_address (string address) ``{
    list(string) parts = splitstring (address, "@");
    if (size (parts) != 2)
    {
	return false;
    }

    return check_mail_local_part (parts[0]:"")
	&& check_domainname (parts[1]:"");
}

/**
 * A list to check entered user names against.
 * It is initialized on first use.
 */
global list(string) local_users = nil;

/**
 * Read user names from passwd.
 * It does not get the NIS entries, that's why one combo is editable.
 */
global define void InitializeLocalUsers () ``{
    // initialize the list
    // CHECK .etc.passwd is in yast2
    list(map) passwd = SCR::Read (.etc.passwd);
    local_users = maplist (map entry, passwd, ``(entry["username"]:"") );
    local_users = sort (filter (string u, local_users, ``(u != "+")));
}

/**
 * D2.1.1
 * Used for adding and editing a user masquerading entry.
 * @param default	$["user": "address":] or just $[]
 * @param existing	current masqueading list
 * @return		$["comment": "", "user": "address":] or $[] on cancel
 */
global define map MasqueradeUserPopup (map default, list(map) existing) ``{
    string user = lookup (default, "user", "");
    string address = lookup (default, "address", "");
    list(string) forbidden = maplist (`e, existing, ``( lookup (e, "user", "") ));

    if (!Mode::config && local_users == nil)
    {
	InitializeLocalUsers ();
    }

    term contents =
	`HBox(
	    `HSpacing(1),
	    `VBox(
		`VSpacing(0.2),
		// Translators: popup dialog heading
		`Heading (_("Sender address rewriting")),
		Mode::config ?
		// Translators: text entry label
		`Left (`TextEntry (`id (`user), _("&Local user"), user)) :
		`Left (`ComboBox (`id (`user), `opt (`editable), _("&Local user"), local_users)),
		// Translators: text entry label
		`Left (`TextEntry (`id (`address), _("&Display as"), address)),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
		      `PushButton(`id(`cancel), CancelButtonLabel())),
		`VSpacing(0.2)
		),
	    `HSpacing(1)
	);

    UI::OpenDialog (`opt(`decorated), contents);
    UI::ChangeWidget (`id (`user), `Value, user);
    UI::SetFocus (`id (`user));

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    break;
	}
	else if (ret == `ok)
	{
	    // Input validation
	    user = UI::QueryWidget (`id (`user), `Value);
	    address = UI::QueryWidget (`id (`address), `Value);


	    if (!check_username (user))
	    {
		UI::SetFocus (`id (`user));
		UI::ErrorPopup (valid_username ());
	    }
	    else if (contains (forbidden, user))
	    {
		UI::SetFocus (`id (`user));
		// Translators: error message
		UI::ErrorPopup (_("The address for this user is already defined."));
	    }
	    else if (!check_mail_address (address))
	    {
		// string valid_mail_address
		// no-spaces@valid_domainname
		UI::SetFocus (`id (`address));
		UI::ErrorPopup (_("The mail address format is incorrect."));
	    }
	    else
	    {
		// all checks OK, break the input loop
		break;
	    }
	}
    }

    UI::CloseDialog ();

    return (ret == `ok)? $["comment": "", "user": user, "address": address] : $[];
}

/**
 * @return `yes if connection_type is `dialup, otherwise `no
 */
global define symbol DialupOnly () ``{
    return Mail::connection_type == `dialup ? `yes: `no;
}

/**
 * D3
 * @return `back, `abort or `next
 */
global define symbol DownloadingDialog () ``{
    //List of maps: $[server:, protocol:, remote_user:, local_user:, password:]
    list(map) fm = Mail::fetchmail;

    // Translators: dialog caption
    string caption = _("Mail downloading");
    term contents =
	`VBox (
	    `VSpacing (0.2),
	    `Table (
		`id (`tab),
		`opt (`notify, `immediate),
		// Translators: table column headings
		`header (_("Server"), _("Protocol"), _("User"), _("Local user")),
		makeItems (fm, ["server", "protocol", "remote_user", "local_user"])
		),
/*
	    `HBox (
		`HWeight (1, `ComboBox (`id (`user), `opt (`editable), _("Local user"),
					["holly", "jane", "tarzan"])),
		`HWeight (2, `TextEntry (`id (`address), _("Display as"), "holly@red.dwarf"))
		),
*/
	    `HBox(
		// Translators: button
		`PushButton(`id(`add), _("A&dd")),
		// Translators: button
		`PushButton(`id(`edit), _("&Edit")),
		// Translators: button
		`PushButton(`id(`delete), _("De&lete"))
		),
	    `VSpacing (0.2)
	    );

    Wizard::SetContentsButtons (caption, contents, DownloadingDialogHelp (), BackButtonLabel (), FinishButtonLabel ());

    UI::ChangeWidget (`id (`edit), `Enabled, false);
    UI::ChangeWidget (`id (`delete), `Enabled, false);

    any ret = nil;
    edit_touched = false;
    while (true)
    {
	boolean any_items = UI::QueryWidget (`id (`tab), `CurrentItem) != nil;
	UI::ChangeWidget (`id (`edit), `Enabled, any_items);
	UI::ChangeWidget (`id (`delete), `Enabled, any_items);

	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}


	if (contains ([`add, `edit, `delete], ret))
	{
	    fm = EditTable(ret, fm, ["server", "protocol", "remote_user", "local_user"], ``(FetchmailPopup ()), `tab);
	}
	else if ((ret == `abort
		  && UI::ReallyAbortPopup (Mail::touched || edit_touched))
		 || ret == `next || ret == `back)
	{
	    break;
	}
    }

    if (ret == `next)
    {
	Mail::Touch (Mail::fetchmail != fm);
	Mail::fetchmail = fm;
    }
    return ret;
}

/**
 * D3.1
 * @param default
 *	$[server:, protocol:, remote_user:, local_user:, password:, ...]
 * @param existing	unused
 * @return edited data (with no other fields) or $[] on cancel
 */
global define map FetchmailPopup (map default, list(map) existing) ``{
    string server = lookup (default, "server", "");
    string protocol = lookup (default, "protocol", "AUTO");
    string ruser = lookup (default, "remote_user", "");
    string password = lookup (default, "password", "");
    string luser = lookup (default, "local_user", "");

    if (local_users == nil)
    {
	InitializeLocalUsers ();
    }

    term contents =
	`HBox(
	    `HSpacing(1),
	    `VBox(
		`VSpacing(0.2),
		// Translators: popup dialog heading
		`Heading (_("Mail downloading")),
		// Translators: text entry label
		`Left (`TextEntry (`id (`server), _("&Server"), server)),
		// Translators: combo box label
		`Left (`ComboBox (`id (`protocol), _("&Protocol"), Mail::protocol_choices)),
		// Translators: text entry label
		`Left (`TextEntry (`id (`ruser), _("&Remote user name"), ruser)),
		// Translators: text entry label
		`Left (`Password (`id (`password1), _("P&assword"), password)),
		// Translators: text entry label
		`Left (`Password (`id (`password2), _("Reenter pass&word"), password)),
		// editable because entering a mail alias makes sense too
		// Translators: text entry label
		`Left (`ComboBox (`id (`luser), `opt (`editable), _("&Local user"), local_users)),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
		      `PushButton(`id(`cancel), CancelButtonLabel())),
		`VSpacing(0.2)
		),
	    `HSpacing(1)
	);

    UI::OpenDialog (`opt(`decorated), contents);
    UI::ChangeWidget (`id (`protocol), `Value, protocol);
    UI::ChangeWidget (`id (`luser), `Value, luser);
    UI::SetFocus (`id (`server));

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    break;
	}
	else if (ret == `ok)
	{
	    // Input validation
	    server = UI::QueryWidget (`id (`server), `Value);
	    protocol = UI::QueryWidget (`id (`protocol), `Value);
	    ruser = UI::QueryWidget (`id (`ruser), `Value);
	    password = UI::QueryWidget (`id (`password1), `Value);
	    luser = UI::QueryWidget (`id (`luser), `Value);

	    string password2 = UI::QueryWidget (`id (`password2), `Value);

	    if (!check_domainname (server))
	    {
		UI::SetFocus (`id (`server));
		// Translators: error popup
		// Already in Translation Memory
		string msg = _("The host name is incorrect");
		UI::ErrorPopup (msg);
	    }
	    else if (ruser == "")
	    {
		UI::SetFocus (`id (`ruser));
		UI::ErrorPopup (_("The user name format is incorrect."));
	    }
	    else if (password != password2)
	    {
		UI::SetFocus (`id (`password1));
		// Translators: error message
		UI::ErrorPopup (_("The passwords do not match."));
	    }
	    else if (!check_mail_local_part (luser))
		// it may be ok if it is directed to an alias
	    {
		UI::SetFocus (`id (`luser));
		UI::ErrorPopup (_("The user name format is incorrect."));
	    }
	    else
	    {
		// all checks OK, break the input loop
		break;
	    }
	}
    }

    UI::CloseDialog ();

    return (ret == `ok)? $["server": server, "protocol": protocol, "remote_user": ruser, "password": password, "local_user": luser] : $[];
}

/**
 * D1.1
 * @return `back, `abort or `next
 */
global define symbol AliasesDialog () ``{
    list(map) aliases = Mail::aliases;

    // Translators: dialog caption
    string caption = _("Aliases");
    term contents =
	`VBox (
	    `VSpacing (0.2),
	    `Table (
		`id (`tab),
		`opt (`notify, `immediate),
		// Translators: table column headings
		`header (_("Alias"), _("Destinations")),
		makeItems (aliases, ["alias", "destinations"])
		),
	    `HBox(
		// Translators: button
		`PushButton(`id(`add), _("A&dd")),
		// Translators: button
		`PushButton(`id(`edit), _("&Edit")),
		// Translators: button
		`PushButton(`id(`delete), _("De&lete"))
		),
	    `VSpacing (0.2)
	    );

    Wizard::SetContentsButtons (caption, contents, AliasesDialogHelp (), BackButtonLabel (), OKButtonLabel ());

    any ret = nil;
    edit_touched = false;
    while (true)
    {
	boolean any_items = UI::QueryWidget (`id (`tab), `CurrentItem) != nil;
	UI::ChangeWidget (`id (`edit), `Enabled, any_items);
	UI::ChangeWidget (`id (`delete), `Enabled, any_items);

	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}

	if (contains ([`add, `edit, `delete], ret))
	{
	    aliases = EditTable(ret, aliases, ["alias", "destinations"], ``(AliasPopup ()), `tab);
	}
	else if (ret == "man_aliases")
	{
	    y2milestone ("TODO: man aliases");
	}
	else if ((ret == `abort
		  && UI::ReallyAbortPopup (Mail::touched || edit_touched))
		 || ret == `next || ret == `back)
	{
	    break;
	}
    }

    if (ret == `next)
    {
	Mail::Touch (Mail::aliases != aliases);
	Mail::aliases = aliases;
    }
    return ret;

}

/**
 * D1.1.1, 1.2.1
 * Used for adding and editing an alias/virtual domain entry.
 * @param default	$["alias": "destinations": ?comment] or just $[]
 * @param existing	current entry list
 * @return		$["comment": ""?, "alias": "destinations":] or $[] on cancel
 */
global define map AliasPopup (map default, list(map) existing) ``{
    string alias = lookup (default, "alias", "");
    string destinations = lookup (default, "destinations", "");
    list(string) forbidden = maplist (`e, existing, ``( lookup (e, "alias", "") ));

    term contents =
	`HBox(
	    `HSpacing(1),
	    `VBox(
		`VSpacing(0.2),
		// Translators: popup dialog heading
		`Heading (_("Incoming mail redirection")),
		// Translators: text entry label
		`Left (`TextEntry (`id (`alias), _("&Alias"), alias)),
		// Translators: text entry label
		`Left (`TextEntry (`id (`destinations), _("&Destinations"), destinations)),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
		      `PushButton(`id(`cancel), CancelButtonLabel())),
		`VSpacing(0.2)
		),
	    `HSpacing(1)
	);

    UI::OpenDialog (`opt(`decorated), contents);
    UI::SetFocus (`id (`alias));

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    break;
	}
	else if (ret == `ok)
	{
	    // Input validation
	    alias = UI::QueryWidget (`id (`alias), `Value);
	    destinations = UI::QueryWidget (`id (`destinations), `Value);

	    // TODO: this only works because check_mail_local part is too
	    // permissive. Virtusertable aliases may contain @ so it is not
	    // a local part and the check will need to be improved.
	    // (But a postfix-style virtual domain will have an @-less entry.)
	    if (!check_mail_local_part (alias))
	    {
		UI::SetFocus (`id (`alias));
		// Translators: error message
		UI::MessagePopup (_("The alias format is incorrect."));
	    }
	    else if (contains (forbidden, alias))
	    {
		UI::SetFocus (`id (`alias));
		// Translators: error message
		UI::MessagePopup (_("The destinations for this alias are already defined."));
	    }
	    else
	    {
		// all checks OK, break the input loop
		break;
	    }
	}
    }

    UI::CloseDialog ();

    return (ret == `ok)? $["comment": "", "alias": alias, "destinations": destinations] : $[];
}



/**
 * D1.2
 * @return `back, `abort or `next
 */
global define symbol VirtualDialog () ``{
    list(map) vu = Mail::virtual_users;

    // Translators: dialog caption
    string caption = _("Virtual domains");
    term contents =
	`VBox (
	    `VSpacing (0.2),
	    `Table (
		`id (`tab),
		`opt (`notify, `immediate),
		// Translators: table column headings
		`header (_("Alias"), _("Destinations")),
		makeItems (vu, ["alias", "destinations"])
		),
	    `HBox(
		// Translators: button
		`PushButton(`id(`add), _("A&dd")),
		// Translators: button
		`PushButton(`id(`edit), _("&Edit")),
		// Translators: button
		`PushButton(`id(`delete), _("De&lete"))
		),
	    `VSpacing (0.2)
	    );

    Wizard::SetContentsButtons (caption, contents, VirtualDialogHelp (), BackButtonLabel (), OKButtonLabel ());

    UI::ChangeWidget (`id (`edit), `Enabled, false);
    UI::ChangeWidget (`id (`delete), `Enabled, false);

    any ret = nil;
    edit_touched = false;
    while (true)
    {
	boolean any_items = UI::QueryWidget (`id (`tab), `CurrentItem) != nil;
	UI::ChangeWidget (`id (`edit), `Enabled, any_items);
	UI::ChangeWidget (`id (`delete), `Enabled, any_items);

	ret = UI::UserInput ();
	if (ret == `cancel)
	{
	    ret = `abort;
	}


	if (contains ([`add, `edit, `delete], ret))
	{
	    vu = EditTable(ret, vu, ["alias", "destinations"], ``(AliasPopup ()), `tab);
	}
	else if ((ret == `abort
		  && UI::ReallyAbortPopup (Mail::touched || edit_touched))
		 || ret == `next || ret == `back)
	{
	    break;
	}
    }

    if (ret == `next)
    {
	Mail::Touch (Mail::virtual_users != vu);
	Mail::virtual_users = vu;;
    }
    return ret;

}

}
