/**
 * File:
 *   modules/Mail.ycp
 *
 * Package:
 *   Configuration of mail
 *
 * Summary:
 *   Data for configuration of mail, input and output functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of mail.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Mail";

    /**
     * `sendmail, `postfix or `other
     */
    global symbol mta = `sendmail;

    /**
     * `permanent, `dialup or `none
     */
    global symbol connection_type = `permanent;

    /**
     * Domains for locally delivered mail.
     * (ahost.acompany.com is a domain)
     */
    global list(string) local_domains = [];

    /**
     * A relay server for outgoing mail.
     */
    global string outgoing_mail_server = "";

    /**
     * Mail will appear to come from this domain. Applies also for the
     * envelope. Does not apply for mail from root.
     */
    global string from_header = "";

    /**
     * If empty, from_header will be applied to mails coming from
     * local_domains, otherwise from these domains. (Remember: mail
     * domains)
     */
    global list(string) masquerade_other_domains = [];

    /**
     * User specific sender masquerading.
     * List of maps: $[comment:, user:, address:] (all are strings)
     */
    global list(map) masquerade_users = [];

    /**
     *List of maps: $[server:, protocol:, remote_user:, local_user:, password:]
     */
    global list(map) fetchmail = [];

    /**
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) aliases = [];

    /**
     * Useful for autoinstall: the provided aliases will be (with
     * higher priority) merged with existing ones (presumably system defaults).
     */
    global boolean merge_aliases = false;

    /**
     * Domain-specific aliases.
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) virtual_users = [];

    /* ---------------------------------------------------------------- */

    /**
     * Fetchmail protocols, as defined in rcfile_l.l
     * Probably not all of them are compatible with our simplified scheme
     * but it does not hurt to include them.
     * Must check for validity: the agent matches [[:alnum:]]+,
     * lowercase names are valid too.
     */
    global list(string) protocol_choices = [
	"AUTO",
	"POP2",
	"POP3",
	"IMAP",
	"APOP",
	"KPOP",
	"SDPS",
	"ETRN",
	"ODMR",
	];

    /* ---------------------------------------------------------------- */

    global define void DemoData () ``{
	connection_type = `dialup;
	local_domains = [];
	outgoing_mail_server = "smtp.provider.com";
	from_header = "mycompany.com";
	masquerade_other_domains = [];
	masquerade_users = [
	    $[ "comment": "", "user": "tarzan", "address": "tarzan@jungle.net" ],
	    $[ "comment": "", "user": "jane",   "address": "matrix@vector.int" ],
	    $[ "comment": "", "user": "holly",   "address": "holly@red.dwarf" ],
	    ];
	fetchmail = [
	    $[ "server": "pop3.provider.com", "protocol": "auto", "remote_user": "taz", "local_user": "tarzan", "password": "foo"],
	    $[ "server": "mail.hosting.net", "protocol": "imap4", "remote_user": "janedoe", "local_user": "jane", "password": "bar"],
	    ];
	aliases = [
	    $[ "comment": "", "alias": "root", "destinations": "mvidner@suse.cz"],
	    $[ "comment": "", "alias": "postmaster", "destinations": "root"],
	    $[ "comment": "", "alias": "mailer-daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "virusalert", "destinations": "root"],
	    $[ "comment": "", "alias": "administrator", "destinations": "root"],
	    $[ "comment": "", "alias": "daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "majordomo", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo\""],
	    $[ "comment": "", "alias": "test", "destinations": "\"|/usr/lib/majordomo/wrapper resend -l test test-outgoing\""],
	    $[ "comment": "", "alias": "test-outgoing", "destinations": ":include:/var/lib/majordomo/lists/test"],
	    $[ "comment": "", "alias": "test-request", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo -l test\""],
	    $[ "comment": "", "alias": "test-approval", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-outgoing", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-request", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test", "destinations": "root"],
	    ];
	virtual_users = [
	    $[ "comment": "", "alias": "info@foo.com", "destinations": "foo-info"],
	    $[ "comment": "", "alias": "info@bar.com", "destinations": "bar-info"],
	    $[ "comment": "", "alias": "@baz.org", "destinations": "jane@example.net"],
	    ];
    }

    /* ---------------------------------------------------------------- */

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Mail::touched
     * @example Mail::Touch (Mail::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read all mail settings from the SCR
     * @param increase_progress A block that will be evaluated after each milestone.
     *        It must return boolean to get known when we should stop after [Abort]
     * @return True on success
     */
    global define boolean Read (block increase_progress) ``{
	boolean read_aborted = false;

	// TODO FIXME: your code here (fill the above mentioned variables)...
	DemoData ();

	integer step = 0;
	while (step < 3)
	{
	    read_aborted = !eval (increase_progress);
	    if (read_aborted)
	    {
		break;
	    }

	    sleep (500);
	    step = step + 1;
	};

	// increase the progress to "finish"
	eval (increase_progress);
	return !read_aborted;
    }

    /**
     * Update the SCR according to mail settings
     * @param increase_progress A block that will be evaluated after each milestone.
     *        It must return boolean to get known when we should stop after [Abort]
     * @param really_abort A block that will be evaluated after [Abort],
     *        because [Abort] in the time of writing could be critical...
     *        It must return boolean to get known if we should really stop.
     * @return True on success
     */
    global define boolean Write (block increase_progress, block really_abort) ``{
	boolean write_aborted = false;

	// TODO FIXME: your code here (store the above mentioned variables)...
	integer step = 0;
	while (step < 2)
	{
	    write_aborted = !eval (increase_progress);
	    if (write_aborted && eval (really_abort))
	    {
		break;
	    }
	    write_aborted = false;

	    sleep (500);
	    step = step + 1;
	};

	// increase the progress to "finish"
	eval (increase_progress);
	return !write_aborted;
    }

    /**
     * Get all mail settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return True on success
     */
    global define boolean Import (map settings) ``{
	// TODO FIXME: your code here (fill the above mentioned variables)...
	sleep (3000);
	return true;
    }

    /**
     * Dump the mail settings to a single map
     * (For use by autoinstallation.)
     * @return Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	// TODO FIXME: your code here (return the above mentioned variables)...
	sleep (3000);
	return $[];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }

    // TODO FIXME: Your code (the needed operations with the settings)
    // TODO FIXME: For example remembering the card being currently
    // TODO FIXME: configured and storing it to the structures, etc.
}
