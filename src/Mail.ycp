/**
 * File:
 *   modules/Mail.ycp
 *
 * Package:
 *   Configuration of mail
 *
 * Summary:
 *   Data for configuration of mail, input and output functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of mail.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Mail";
    textdomain "mail";

    import "Report";

    /**
     * `sendmail, `postfix or `other
     */
    global symbol mta = `sendmail;

    /**
     * `permanent, `dialup or `none
     */
    global symbol connection_type = `permanent;

    /**
     * Domains for locally delivered mail.
     * (ahost.acompany.com is a domain)
     */
    global list(string) local_domains = [];

    /**
     * A relay server for outgoing mail.
     */
    global string outgoing_mail_server = "";

    /**
     * Mail will appear to come from this domain. Applies also for the
     * envelope. Does not apply for mail from root.
     */
    global string from_header = "";

    /**
     * If empty, from_header will be applied to mails coming from
     * local_domains, otherwise from these domains. (Remember: mail
     * domains)
     */
    global list(string) masquerade_other_domains = [];

    /**
     * User specific sender masquerading.
     * List of maps: $[comment:, user:, address:] (all are strings)
     */
    global list(map) masquerade_users = [];

    /**
     *List of maps: $[server:, protocol:, remote_user:, local_user:, password:]
     */
    global list(map) fetchmail = [];

    /**
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) aliases = [];

    /**
     * Useful for autoinstall: the provided aliases will be (with
     * higher priority) merged with existing ones (presumably system defaults).
     */
    global boolean merge_aliases = false;

    /**
     * Domain-specific aliases.
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) virtual_users = [];

    /* ---------------------------------------------------------------- */

    /**
     * Fetchmail protocols, as defined in rcfile_l.l
     * Probably not all of them are compatible with our simplified scheme
     * but it does not hurt to include them.
     * Must check for validity: the agent matches [[:alnum:]]+,
     * lowercase names are valid too.
     */
    global list(string) protocol_choices = [
	"AUTO",
	"POP2",
	"POP3",
	"IMAP",
	"APOP",
	"KPOP",
	"SDPS",
	"ETRN",
	"ODMR",
	];

    /* ---------------------------------------------------------------- */

    /**
     * Fake data to test dialogs on until Reading works
     */
    global define void DemoData () ``{
	connection_type = `dialup;
	local_domains = [];
	outgoing_mail_server = "smtp.provider.com";
	from_header = "mycompany.com";
	masquerade_other_domains = [];
	masquerade_users = [
	    $[ "comment": "", "user": "tarzan", "address": "tarzan@jungle.net" ],
	    $[ "comment": "", "user": "jane",   "address": "matrix@vector.int" ],
	    $[ "comment": "", "user": "holly",   "address": "holly@red.dwarf" ],
	    ];
	fetchmail = [
	    $[ "server": "pop3.provider.com", "protocol": "auto", "remote_user": "taz", "local_user": "tarzan", "password": "foo"],
	    $[ "server": "mail.hosting.net", "protocol": "imap4", "remote_user": "janedoe", "local_user": "jane", "password": "bar"],
	    ];
	aliases = [
	    $[ "comment": "", "alias": "root", "destinations": "mvidner@suse.cz"],
	    $[ "comment": "", "alias": "postmaster", "destinations": "root"],
	    $[ "comment": "", "alias": "mailer-daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "virusalert", "destinations": "root"],
	    $[ "comment": "", "alias": "administrator", "destinations": "root"],
	    $[ "comment": "", "alias": "daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "majordomo", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo\""],
	    $[ "comment": "", "alias": "test", "destinations": "\"|/usr/lib/majordomo/wrapper resend -l test test-outgoing\""],
	    $[ "comment": "", "alias": "test-outgoing", "destinations": ":include:/var/lib/majordomo/lists/test"],
	    $[ "comment": "", "alias": "test-request", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo -l test\""],
	    $[ "comment": "", "alias": "test-approval", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-outgoing", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-request", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test", "destinations": "root"],
	    ];
	virtual_users = [
	    $[ "comment": "", "alias": "info@foo.com", "destinations": "foo-info"],
	    $[ "comment": "", "alias": "info@bar.com", "destinations": "bar-info"],
	    $[ "comment": "", "alias": "@baz.org", "destinations": "jane@example.net"],
	    ];
    }

    /* ---------------------------------------------------------------- */

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Mail::touched
     * @example Mail::Touch (Mail::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read all mail settings from the SCR
     * @param abort A block that can be called by Read to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Read (block abort) ``{

	DemoData ();

	string caption = _("Initializing mail configuration");

	Progress::New (caption, " ", 0, [
			   // do not translate MTA
			   _("Determine Mail Transport Agent (MTA)"),
			   _("Read general settings"),
			   _("Read masquerading settings"),
			   _("Read downloading settings"),
			   _("Read alias tables"),
			   ],
		       [], "");

	// announce 1
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 1
	if (SCR::Read (.targetpkg.installed, "sendmail"))
	{
	    mta = `sendmail;
	}
	else if (SCR::Read (.targetpkg.installed, "postfix"))
	{
	    mta = `postfix;
	}
	else
	{
	    mta = `other;
	}

	if (mta == `other)
	{
	    // TODO: adapt workflow to say sorry and bye.
	    return true;
	}

	// announce 2
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 2
	// connection_type:
	boolean nc = false;
	boolean ex = false;
	if (mta == `sendmail)
	{
	    nc = SCR::Read (.sysconfig.sendmail.SENDMAIL_NOCANONIFY) == "yes";
	    ex = SCR::Read (.sysconfig.sendmail.SENDMAIL_EXPENSIVE) == "yes";
	}
	else if (mta == `postfix)
	{
	    nc = SCR::Read (.sysconfig.postfix.POSTFIX_NODNS) == "yes";
	    ex = SCR::Read (.sysconfig.postfix.DIALUP) == "yes";
	}
	else
	{
	    return false;
	}

	if (nc)
	{
	    connection_type = (ex)? `dialup : `none;
	}
	else
	{
	    connection_type = `permanent;
	}

	// local_domains
	string ld_s = "";
	if (mta == `sendmail)
	{
	    ld_s = SCR::Read (.sysconfig.sendmail.SENDMAIL_LOCALHOST);
	}
	else if (mta == `postfix)
	{
	    ld_s = SCR::Read (.sysconfig.postfix.POSTFIX_LOCALDOMAINS);
	}
	else
	{
	    return false;
	}
	local_domains = filter (`s, splitstring (ld_s, " ,;"), ``(s != ""));

	// outgoing_mail_server
	if (mta == `sendmail)
	{
	    outgoing_mail_server = SCR::Read (.sysconfig.sendmail.SENDMAIL_SMARTHOST);
	}
	else if (mta == `postfix)
	{
	    string oms = SCR::Read (.sysconfig.postfix.POSTFIX_RELAYHOST);
	    // strip brackets, if any
	    outgoing_mail_server = select (regexptokenize (oms, "\\[(.*)\\]"), 0, oms);
	}
	else
	{
	    return false;
	}

	// announce 3
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 3
	// from_header
	from_header = SCR::Read (.sysconfig.mail.FROM_HEADER);
	// handle nonexistent file
	if (from_header == nil)
	{
	    from_header = "";
	}

	// masquerade_other_domains
	string mod_s = "";
	if (mta == `sendmail)
	{
	    mod_s = SCR::Read (.sysconfig.sendmail.MASQUERADE_DOMAINS);
	}
	else if (mta == `postfix)
	{
	    mod_s = SCR::Read (.sysconfig.postfix.POSTFIX_MASQUERADE_DOMAIN);
	}
	else
	{
	    return false;
	}
	masquerade_other_domains = filter (`s, splitstring (mod_s, " ,;"), ``(s != ""));

	// masquerade_users
	list(map) mu_raw = [];
	if (mta == `sendmail)
	{
	    mu_raw = SCR::Read (.mail.sendmail.generics.table);
	}
	else if (mta == `postfix)
	{
	    mu_raw = SCR::Read (.mail.postfix.sendercanonical.table);
	}
	else
	{
	    return false;
	}
	masquerade_users = maplist (map e, mu_raw,
				    ``($[
					   "comment"	: e["comment"]: "",
					   "user"	: e["key"]: "",
					   "address"	: e["value"]: "",
					   ]));

	// announce 4
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 4
	fetchmail = SCR::Read (.mail.fetchmail.accounts);
	//TODO what to do with a difficult syntax etc?

	// announce 5
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 5
	merge_aliases = false;

	// aliases
	list(map) a_raw = [];
	if (mta == `sendmail)
	{
	    a_raw = SCR::Read (.mail.sendmail.aliases.table);
	}
	else if (mta == `postfix)
	{
	    a_raw = SCR::Read (.mail.postfix.aliases.table);
	}
	else
	{
	    return false;
	}
	aliases =  maplist (map e, a_raw,
			    ``($[
				   "comment"		: e["comment"]: "",
				   "alias"		: e["key"]: "",
				   "destinations"	: e["value"]: "",
				   ]));

	// virtual_users
	list(map) v_raw = [];
	if (mta == `sendmail)
	{
	    v_raw = SCR::Read (.mail.sendmail.virtuser.table);
	}
	else if (mta == `postfix)
	{
	    v_raw = SCR::Read (.mail.postfix.virtual.table);
	}
	else
	{
	    return false;
	}
	virtual_users =  maplist (map e, v_raw,
				  ``($[
					 "comment"	: e["comment"]: "",
					 "alias"	: e["key"]: "",
					 "destinations"	: e["value"]: "",
					 ]));


	// TODO what about the daemon (was .rc.system.SMTP)

	// complete
	Progress::NextStage ();
	return true;
    }

    // document and TEST
    /**
     * Merges mail tables, which are order-preserving maps.
     * First are the entries of the old map, with values updated
     * from the new one, then the rest of the new map.
     * @param new	new table
     * @param old	old table
     * @return		merged table
     */
    define list(map) mergeTables (list(map) new, list(map) old) ``{
	// make a true map
	map new_m = listmap (map e, new,
			     ``([
				    e["key"]:"",
				    [ e["comment"]:"", e["value"]:"" ]
				    ]));
	// update old values
	list(map) replaced = maplist (map e, old, ``{
	    string k = e["key"]:"";
	    list cv = new_m[k]:[];
	    if (size (cv) > 0)
	    {
		new_m[k] = []; // ok, newly constructed
		return $["key": k, "comment": cv[0]:"", "value": cv[1]:""];
	    }
	    else
	    {
		return $["key": k, "comment": e["comment"]:"", "value": e["value"]:""];
	    }
	});
	// remove already updated values
	list(map) filtered = filter (map e, new, ``(
					 size (new_m[ e["key"]:"" ]:[]) > 0)
	    );
	return flatten ([replaced, filtered]);
    }

    /**
     * Update the SCR according to mail settings
     * @param abort A block that can be called by Write to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Write (block abort) ``{
	list stages = [
	    [ _("Write general settings"), ``(WriteGeneral ())],
	    ];
	if (connection_type != `none)
	{
	    stages = add (stages, [ _("Write masquerading settings"), ``(WriteMasquerading ()) ]);
	    if (connection_type == `dialup)
	    {
		stages = add (stages, [ _("Write downloading settings"), ``(WriteDownloading ()) ]);
	    }
	    stages = add (stages, [ _("Write alias tables"), ``(WriteAliases ()) ]);
	}
	stages = add (stages, [ _("Run SuSEconfig"), ``(WriteFinish ()) ]);

	string caption = _("Saving mail configuration");
	// We do not set help text here, because it was set outside
	Progress::New (caption, " ", 0, maplist (list e, stages, ``(e[0]:"")), [], "");

	foreach (list e, stages, ``{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return false;
	    }

	    term f = e[1]:``(false);
	    if (! eval (f))
	    {
		return false;
	    }
	});

	// complete
	Progress::NextStage ();
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteGeneral () ``{
	// connection_type
	if (mta == `sendmail)
	{
	    path nc = .sysconfig.sendmail.SENDMAIL_NOCANONIFY;
	    path ex = .sysconfig.sendmail.SENDMAIL_EXPENSIVE;
	    if (connection_type == `permanent)
	    {
		SCR::Write (nc, "no");
		SCR::Write (ex, "no");
	    }
	    else if (connection_type == `dialup)
	    {
		SCR::Write (nc, "yes");
		SCR::Write (ex, "yes");
	    }
	    else if (connection_type == `none)
	    {
		SCR::Write (nc, "yes");
		SCR::Write (ex, "no");
	    }
	    else
	    {
		y2internal("Unrecognized connection_type: %1", connection_type);
		return false;
	    }
	}
	else if (mta == `postfix)
	{
	    path nd = .sysconfig.postfix.POSTFIX_NODNS;
	    path di = .sysconfig.postfix.POSTFIX_DIALUP;
	    if (connection_type == `permanent)
	    {
		SCR::Write (nd, "no");
		SCR::Write (di, "no");
	    }
	    else if (connection_type == `dialup)
	    {
		SCR::Write (nd, "yes");
		SCR::Write (di, "yes");
	    }
	    else if (connection_type == `none)
	    {
		SCR::Write (nd, "yes");
		SCR::Write (di, "no");
	    }
	    else
	    {
		y2internal("Unrecognized connection_type: %1", connection_type);
		return false;
	    }
	}
	else
	{
	    return false;
	}

	// local_domains
	if (mta == `sendmail)
	{
	    string ld_s = mergestring (local_domains, " ");
	    SCR::Write (.sysconfig.sendmail.SENDMAIL_LOCALHOST, ld_s);
	}
	else if (mta == `postfix)
	{
	    string ld_s = mergestring (local_domains, ","); // noted in #12672
	    SCR::Write (.sysconfig.postfix.POSTFIX_LOCALDOMAINS, ld_s);
	}
	else
	{
	    return false;
	}

	// outgoing_mail_server
	if (mta == `sendmail)
	{
	    SCR::Write (.sysconfig.sendmail.SENDMAIL_SMARTHOST, outgoing_mail_server);
	}
	else if (mta == `postfix)
	{
	    string oms = sformat ("[%1]", outgoing_mail_server);
	    SCR::Write (.sysconfig.postfix.POSTFIX_RELAYHOST, oms);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteMasquerading () ``{
	// from_header
	SCR::Write (.sysconfig.mail.FROM_HEADER, from_header);
	// masquerade_other_domains
	if (mta == `sendmail)
	{
	    string mod = mergestring (masquerade_other_domains, " ");
	    SCR::Write (.sysconfig.sendmail.MASQUERADE_DOMAINS, mod);
	}
	else if (mta == `postfix)
	{
	    string mod = mergestring (masquerade_other_domains, ",");
	    SCR::Write (.sysconfig.postfix.POSTFIX_MASQUERADE_DOMAIN, mod);
	}
	else
	{
	    return false;
	}

	// masquerade_users
	list(map) mu_raw = maplist (map e, masquerade_users,
				    ``($[
					   "comment"	: e["comment"]:"",
					   // TODO check that nonempty
					   "key"	: e["user"]:"",
					   "value"	: e["address"]:"",
					   ]));
	if (mta == `sendmail)
	{
	    SCR::Write (.mail.sendmail.generics.table, mu_raw);
	}
	else if (mta == `postfix)
	{
	    SCR::Write (.mail.postfix.sendercanonical.table, mu_raw);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteDownloading () ``{
	// fetchmail
	// TODO ?other settings: autofetch? at device up?
	SCR::Write (.mail.fetchmail.accounts, fetchmail);
	if (! SCR::Write (.mail.fetchmail, nil))
	{
	    Report::Error (_("Error writing Fetchmail configuration."));
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteAliases () ``{
	// aliases
	path alias_path = nil;
	if (mta == `sendmail)
	{
	    alias_path = .mail.sendmail.aliases.table;
	}
	else if (mta == `postfix)
	{
	    alias_path = .mail.postfix.aliases.table;
	}
	else
	{
	    return false;
	}
	list(map) a_raw = maplist (map e, aliases,
				   ``($[
					  "comment"	: e["comment"]:"",
					  "key"		: e["alias"]:"",
					  "value"	: e["destinations"]:"",
					  ]));
	if (merge_aliases)
	{
	    a_raw = mergeTables (a_raw, SCR::Read (alias_path));
	}
	SCR::Write (alias_path, a_raw);


	// virtual_users
	list(map) v_raw = maplist (map e, virtual_users,
				   ``($[
					  "comment"	: e["comment"]:"",
					  "key"		: e["alias"]:"",
					  "value"	: e["destinations"]:"",
					  ]));
	if (mta == `sendmail)
	{
	    SCR::Write (.mail.sendmail.virtuser.table, v_raw);
	}
	else if (mta == `postfix)
	{
	    SCR::Write (.mail.postfix.virtual.table, v_raw);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteFinish () ``{
	//flush the agents
	if (!SCR::Write (.sysconfig.mail, nil))
	{
	    Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/mail"));
	    return false;
	}
	list(path) tables = nil;
	if (mta == `sendmail)
	{
	    if (!SCR::Write (.sysconfig.sendmail, nil))
	    {
		Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/sendmail"));
		return false;
	    }
	    tables = [
		.mail.sendmail.generics,
		.mail.sendmail.aliases,
		.mail.sendmail.virtuser,
		];
	}
	else if (mta == `postfix)
	{
	    if (!SCR::Write (.sysconfig.postfix, nil))
	    {
		Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/postfix"));
		return false;
	    }
	    tables = [
		.mail.postfix.sendercanonical,
		.mail.postfix.aliases,
		.mail.postfix.virtual,
		];
	}
	else
	{
	    return false;
	}

	foreach (path p, tables, ``{
	    if (!SCR::Write (p, nil))
	    {
		string filename = SCR::Read (p + topath (".meta.filename"));
		Report::Error (sformat (_("Error writing file %1"), filename));
		return false;
	    }
	});

	//run SuSEconfig with the necessary modules
	// TODO other modules using FROM_HEADER?
	integer ret = 0;
	if (mta == `sendmail)
	{
	    ret = SCR::Execute (.target.bash, "/sbin/SuSEconfig --module sendmail");
	}
	else if (mta == `postfix)
	{
	    ret = SCR::Execute (.target.bash, "/sbin/SuSEconfig --module postfix");
	}
	else
	{
	    return false;
	}

	if (ret != 0)
	{
	    Report::Error (_("Error running SuSEconfig."));
	    return false;
	}
	return true;
    }

    /**
     * Get all mail settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return True on success
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    return true;
	}

	boolean missing = false;
	foreach (`k, ["mta", "connection_type", "local_domains", "outgoing_mail_server", "from_header", "masquerade_other_domains", "masquerade_users", "fetchmail", "aliases", "merge_aliases", "virtual_users"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}

	mta = settings["mta"]: `other;
	connection_type = settings["connection_type"]: `none;
	local_domains = settings["local_domains"]: [];
	outgoing_mail_server = settings["outgoing_mail_server"]: "";
	from_header = settings["from_header"]: "";
	masquerade_other_domains = settings["masquerade_other_domains"]: [];
	masquerade_users = settings["masquerade_users"]: [];
	fetchmail = settings["fetchmail"]: [];
	aliases = settings["aliases"]: [];
	merge_aliases = settings["merge_aliases"]: false;
	virtual_users = settings["virtual_users"]: [];

	return true;
    }

    /**
     * Dump the mail settings to a single map
     * (For use by autoinstallation.)
     * @return Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	return $[
	    "mta": mta,
	    "connection_type": connection_type,
	    "local_domains": local_domains,
	    "outgoing_mail_server": outgoing_mail_server,
	    "from_header": from_header,
	    "masquerade_other_domains": masquerade_other_domains,
	    "masquerade_users": masquerade_users,
	    "fetchmail": fetchmail,
	    "aliases": aliases,
	    "merge_aliases": merge_aliases,
	    "virtual_users": virtual_users,
	    ];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }
}
