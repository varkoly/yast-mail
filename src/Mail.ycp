/**
 * File:
 *   modules/Mail.ycp
 *
 * Package:
 *   Configuration of mail
 *
 * Summary:
 *   Data for configuration of mail, input and output functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of mail.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Mail";
    textdomain "mail";

    /**
     * `sendmail, `postfix or `other
     */
    global symbol mta = `sendmail;

    /**
     * `permanent, `dialup or `none
     */
    global symbol connection_type = `permanent;

    /**
     * Domains for locally delivered mail.
     * (ahost.acompany.com is a domain)
     */
    global list(string) local_domains = [];

    /**
     * A relay server for outgoing mail.
     */
    global string outgoing_mail_server = "";

    /**
     * Mail will appear to come from this domain. Applies also for the
     * envelope. Does not apply for mail from root.
     */
    global string from_header = "";

    /**
     * If empty, from_header will be applied to mails coming from
     * local_domains, otherwise from these domains. (Remember: mail
     * domains)
     */
    global list(string) masquerade_other_domains = [];

    /**
     * User specific sender masquerading.
     * List of maps: $[comment:, user:, address:] (all are strings)
     */
    global list(map) masquerade_users = [];

    /**
     *List of maps: $[server:, protocol:, remote_user:, local_user:, password:]
     */
    global list(map) fetchmail = [];

    /**
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) aliases = [];

    /**
     * Useful for autoinstall: the provided aliases will be (with
     * higher priority) merged with existing ones (presumably system defaults).
     */
    global boolean merge_aliases = false;

    /**
     * Domain-specific aliases.
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) virtual_users = [];

    /* ---------------------------------------------------------------- */

    /**
     * Fetchmail protocols, as defined in rcfile_l.l
     * Probably not all of them are compatible with our simplified scheme
     * but it does not hurt to include them.
     * Must check for validity: the agent matches [[:alnum:]]+,
     * lowercase names are valid too.
     */
    global list(string) protocol_choices = [
	"AUTO",
	"POP2",
	"POP3",
	"IMAP",
	"APOP",
	"KPOP",
	"SDPS",
	"ETRN",
	"ODMR",
	];

    /* ---------------------------------------------------------------- */

    /**
     * Fake data to test dialogs on until Reading works
     */
    global define void DemoData () ``{
	connection_type = `dialup;
	local_domains = [];
	outgoing_mail_server = "smtp.provider.com";
	from_header = "mycompany.com";
	masquerade_other_domains = [];
	masquerade_users = [
	    $[ "comment": "", "user": "tarzan", "address": "tarzan@jungle.net" ],
	    $[ "comment": "", "user": "jane",   "address": "matrix@vector.int" ],
	    $[ "comment": "", "user": "holly",   "address": "holly@red.dwarf" ],
	    ];
	fetchmail = [
	    $[ "server": "pop3.provider.com", "protocol": "auto", "remote_user": "taz", "local_user": "tarzan", "password": "foo"],
	    $[ "server": "mail.hosting.net", "protocol": "imap4", "remote_user": "janedoe", "local_user": "jane", "password": "bar"],
	    ];
	aliases = [
	    $[ "comment": "", "alias": "root", "destinations": "mvidner@suse.cz"],
	    $[ "comment": "", "alias": "postmaster", "destinations": "root"],
	    $[ "comment": "", "alias": "mailer-daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "virusalert", "destinations": "root"],
	    $[ "comment": "", "alias": "administrator", "destinations": "root"],
	    $[ "comment": "", "alias": "daemon", "destinations": "root"],
	    $[ "comment": "", "alias": "majordomo", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo\""],
	    $[ "comment": "", "alias": "test", "destinations": "\"|/usr/lib/majordomo/wrapper resend -l test test-outgoing\""],
	    $[ "comment": "", "alias": "test-outgoing", "destinations": ":include:/var/lib/majordomo/lists/test"],
	    $[ "comment": "", "alias": "test-request", "destinations": "\"|/usr/lib/majordomo/wrapper majordomo -l test\""],
	    $[ "comment": "", "alias": "test-approval", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-outgoing", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test-request", "destinations": "owner-test"],
	    $[ "comment": "", "alias": "owner-test", "destinations": "root"],
	    ];
	virtual_users = [
	    $[ "comment": "", "alias": "info@foo.com", "destinations": "foo-info"],
	    $[ "comment": "", "alias": "info@bar.com", "destinations": "bar-info"],
	    $[ "comment": "", "alias": "@baz.org", "destinations": "jane@example.net"],
	    ];
    }

    /* ---------------------------------------------------------------- */

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Mail::touched
     * @example Mail::Touch (Mail::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read all mail settings from the SCR
     * @param abort A block that can be called by Read to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Read (block abort) ``{

	DemoData ();

	// TODO FIXME Assign the true texts intead of these
	string caption = _("Initializing XXpkgXX configuration");

	// TODO FIXME Names of real stages
	// We do not set help text here, because it was set outside
	Progress::New (caption, " ", 0, [
			   // do not translate MTA
			   _("Determine Mail Transport Agent (MTA)"),
			   _("Read general settings"),
			   _("Read masquerading settings"),
			   _("Read downloading settings"),
			   _("Read alias tables"),
			   ],
		       [], "");

	// announce 1
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 1
	//TODO: detect properly
	mta = `sendmail;
	if (mta == `other)
	{
	    // TODO: adapt workflow to say sorry and bye.
	    return true;
	}

	// announce 2
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 2
	// connection_type:
	boolean nc = false;
	boolean ex = false;
	if (mta == `sendmail)
	{
	    nc = SCR::Read (.rc.sendmail.SENDMAIL_NOCANONIFY) == "yes";
	    ex = SCR::Read (.rc.sendmail.SENDMAIL_EXPENSIVE) == "yes";
	}
	else if (mta == `postfix)
	{
	    nc = SCR::Read (.rc.postfix.POSTFIX_NODNS) == "yes";
	    ex = SCR::Read (.rc.postfix.DIALUP) == "yes";
	}
	else
	{
	    return false;
	}

	if (nc)
	{
	    connection_type = (ex)? `dialup : `none;
	}
	else
	{
	    connection_type = `permanent;
	}

	// local_domains
	string ld_s = "";
	if (mta == `sendmail)
	{
	    ld_s = SCR::Read (.rc.sendmail.SENDMAIL_LOCALHOST);
	}
	else if (mta == `postfix)
	{
	    ld_s = SCR::Read (.rc.postfix.POSTFIX_LOCALDOMAINS);
	}
	else
	{
	    return false;
	}
	local_domains = filter (`s, splitstring (ld_s, " ,;"), ``(s != ""));

	// outgoing_mail_server
	if (mta == `sendmail)
	{
	    outgoing_mail_server = SCR::Read (.rc.sendmail.SENDMAIL_SMARTHOST);
	}
	else if (mta == `postfix)
	{
	    outgoing_mail_server = SCR::Read (.rc.postfix.POSTFIX_RELAYHOST);
	    // TODO strip [brackets]
	}
	else
	{
	    return false;
	}

	// announce 3
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 3
	// from_header
	from_header = SCR::Read (.rc.system.FROM_HEADER);

	// masquerade_other_domains
	string mod_s = "";
	if (mta == `sendmail)
	{
	    mod_s = SCR::Read (.rc.sendmail.MASQUERADE_DOMAINS);
	}
	else if (mta == `postfix)
	{
	    mod_s = SCR::Read (.rc.postfix.POSTFIX_MASQUERADE_DOMAIN);
	}
	else
	{
	    return false;
	}
	masquerade_other_domains = filter (`s, splitstring (mod_s, " ,;"), ``(s != ""));

	// masquerade_users
	list(map) mu_raw = [];
	if (mta == `sendmail)
	{
	    mu_raw = SCR::Read (.mail.sendmail.generics.table);
	}
	else if (mta == `postfix)
	{
	    mu_raw = SCR::Read (.mail.postfix.sendercanonical.table);
	}
	else
	{
	    return false;
	}
	masquerade_users = maplist (map e, mu_raw,
				    ``($[
					   "comment"	: e["comment"]: "",
					   "user"	: e["key"]: "",
					   "address"	: e["value"]: "",
					   ]));

	// announce 4
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 4
	fetchmail = SCR::Read (.mail.fetchmail.accounts);
	//TODO what to do with a difficult syntax etc?

	// announce 5
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 5
	merge_aliases = false;

	// aliases
	list(map) a_raw = [];
	if (mta == `sendmail)
	{
	    a_raw = SCR::Read (.mail.sendmail.aliases.table);
	}
	else if (mta == `postfix)
	{
	    a_raw = SCR::Read (.mail.postfix.aliases.table);
	}
	else
	{
	    return false;
	}
	aliases =  maplist (map e, a_raw,
			    ``($[
				   "comment"		: e["comment"]: "",
				   "alias"		: e["key"]: "",
				   "destinations"	: e["value"]: "",
				   ]));

	// virtual_users
	list(map) v_raw = [];
	if (mta == `sendmail)
	{
	    v_raw = SCR::Read (.mail.sendmail.virtuser.table);
	}
	else if (mta == `postfix)
	{
	    v_raw = SCR::Read (.mail.postfix.virtual.table);
	}
	else
	{
	    return false;
	}
	virtual_users =  maplist (map e, v_raw,
				  ``($[
					 "comment"	: e["comment"]: "",
					 "alias"	: e["key"]: "",
					 "destinations"	: e["value"]: "",
					 ]));


	// TODO what about SCR::Read(.rc.system.SMTP)

	// complete
	Progress::NextStage ();
	return true;
    }

    /**
     * Update the SCR according to mail settings
     * @param abort A block that can be called by Write to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Write (block abort) ``{
	boolean write_aborted = false;
	// TODO FIXME Assign the true texts intead of these
	string caption = _("Saving XXpkgXX configuration");

	// TODO FIXME Names of real stages
	// We do not set help text here, because it was set outside
	Progress::New (caption, " ", 0, [
			   _("Write the settings"),
			   _("Run SuSEconfig"),
			   ],
		       [], "");

	// TODO FIXME: your code here (store the above mentioned variables)...
	integer stage = 0;
	while (stage < 2)
	{
	    Progress::NextStage ();
	    write_aborted = eval (abort);
	    if (write_aborted)
	    {
		break;
	    }
	    write_aborted = false;

	    sleep (500);
	    stage = stage + 1;
	};

	// increase the progress to "finish"
	Progress::NextStage ();
	return !write_aborted;
    }

    /**
     * Get all mail settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return True on success
     */
    global define boolean Import (map settings) ``{
	// TODO FIXME: your code here (fill the above mentioned variables)...
	sleep (3000);
	return true;
    }

    /**
     * Dump the mail settings to a single map
     * (For use by autoinstallation.)
     * @return Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	// TODO FIXME: your code here (return the above mentioned variables)...
	sleep (3000);
	return $[];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }

    // TODO FIXME: Your code (the needed operations with the settings)
    // TODO FIXME: For example remembering the card being currently
    // TODO FIXME: configured and storing it to the structures, etc.
}
