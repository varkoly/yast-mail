/**
 * File:
 *   modules/Mail.ycp
 *
 * Package:
 *   Configuration of mail
 *
 * Summary:
 *   Data for configuration of mail, input and output functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of mail.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Mail";
    textdomain "mail";

    import "Report";
    import "Runlevel";
    import "Summary";

    /**
     * `sendmail, `postfix or `other
     */
    global symbol mta = `sendmail;

    boolean create_config = false;
    /**
     * If MAIL_CREATE_CONFIG is not yes, the user
     * does not want SuSEconfig to modify sendmail.cf/main.cf.
     * So we will warn him before setting it to yes.
     * @return	Is it yes?
     */
    global define boolean CreateConfig () ``{
	return create_config;
    }

    /**
     * `permanent, `dialup or `none
     */
    global symbol connection_type = `permanent;

    /**
     * Use a virus scanner (AMaViS).
     * amavis-sendmail or amavis-postfix must be installed.
     * It will be installed if amavis_allowed and it is not installed.
     */
    global boolean use_amavis = false;

    /**
     * Is amavis available on the installation media?
     */
    global boolean amavis_allowed = true;

    /**
     * Domains for locally delivered mail.
     * (ahost.acompany.com is a domain)
     */
    global list(string) local_domains = [];

    /**
     * A relay server for outgoing mail.
     * May be enclosed in [brackets] to prevent MX lookups.
     */
    global string outgoing_mail_server = "";

    /**
     * Mail will appear to come from this domain. Applies also for the
     * envelope. Does not apply for mail from root.
     */
    global string from_header = "";

    /**
     * If empty, from_header will be applied to mails coming from
     * local_domains, otherwise from these domains. (Remember: mail
     * domains)
     */
    global list(string) masquerade_other_domains = [];

    /**
     * User specific sender masquerading.
     * List of maps: $[comment:, user:, address:] (all are strings)
     */
    global list(map) masquerade_users = [];

    /**
     *List of maps:
     * $[server:, protocol:, remote_user:, local_user:, password:,
     * enabled:(bool), other_(server|client)_options: ]
     */
    global list fetchmail = [];
//bug 13263
//    global list(map) fetchmail = [];

    /**
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) aliases = [];

    /**
     * Useful for autoinstall: the provided aliases will be (with
     * higher priority) merged with existing ones (presumably system defaults).
     */
    global boolean merge_aliases = false;

    /**
     * Domain-specific aliases.
     * List of maps: $[comment:, alias:, destinations:] (all are strings)
     */
    global list(map) virtual_users = [];

    /* ---------------------------------------------------------------- */

    /**
     * Fetchmail protocols, as defined in rcfile_l.l
     * Probably not all of them are compatible with our simplified scheme
     * but it does not hurt to include them.
     * Must check for validity: the agent matches [[:alnum:]]+,
     * lowercase names are valid too.
     */
    global list(string) protocol_choices = [
	"AUTO",
	"POP2",
	"POP3",
	"IMAP",
	"APOP",
	"KPOP",
	"SDPS",
	"ETRN",
	"ODMR",
	];

    /* ---------------------------------------------------------------- */

    /**
     * True if preparing data for autoinstallation. In that case,
     * do not validate against the current system (eg. user names).
     * TODO: Use Mode::config.
     */
    global boolean autoyast_config = false;

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Mail::touched
     * @example Mail::Touch (Mail::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) install_packages = [];
    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) remove_packages = [];

    /**
     * Detect which packages have to be installed
     * and return a descriptive string for a plain text pop-up.
     * @return "" or "Foo will be installed.\nBar will be installed.\n"
     */
    global define string ProbePackages () ``{
	string message = "";
	install_packages = [];
	remove_packages = [];

	if (use_amavis)
	{
	    string pkg = (mta == `sendmail)? "amavis-sendmail":"amavis-postfix";
	    if (! SCR::Read (.targetpkg.installed, pkg))
	    {
		install_packages = add (install_packages, pkg);
		// Translators: popup message part, ends with a newline
		message = message + _("AMaViS, a virus scanner, will be installed.\n");
	    }
	}

	if (connection_type == `dialup &&
	    size (fetchmail) > 0 &&
	    ! SCR::Read (.targetpkg.installed, "fetchmail"))
	{
	    install_packages = add (install_packages, "fetchmail");
	    // Translators: popup message part, ends with a newline
	    message = message + _("Fetchmail, a mail downloading utility, will be installed.\n");
	}

	return message;
    }

    /**
     * Is a package available for installation?
     * This is a bit kludgy, since querying .package would take up
     * a large amount of resources.
     * @return true/false
     */
    define boolean AvailableForInstallation (string package) ``{
	string cmd = "/usr/bin/grep -q '^RpmName:[ \t]*%1$' %2";
	string pkd = "/var/adm/current_package_descr/suse/setup/descr/common.pkd";
	return SCR::Execute (.target.bash, sformat (cmd, package, pkd)) == 0;
    }
    /* ---------------------------------------------------------------- */

    /**
     * Read all mail settings from the SCR
     * @param abort A block that can be called by Read to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Read (block abort) ``{
	// Translators: dialog caption
	string caption = _("Initializing mail configuration");

	Progress::New (caption, " ", 0, [
			   // Translators: progress label
			   // do not translate MTA
			   _("Determining Mail Transport Agent (MTA)"),
			   // Translators: progress label
			   _("Reading general settings"),
			   // Translators: progress label
			   _("Reading masquerading settings"),
			   // Translators: progress label
			   _("Reading downloading settings"),
			   // Translators: progress label
			   _("Reading alias tables"),
			   ],
		       [], "");

	// announce 1
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 1
	if (SCR::Read (.targetpkg.installed, "sendmail"))
	{
	    mta = `sendmail;
	}
	else if (SCR::Read (.targetpkg.installed, "postfix"))
	{
	    mta = `postfix;
	}
	else
	{
	    mta = `other;
	}

	if (mta == `other)
	{
	    // TODO: adapt workflow to say sorry and bye.
	    return true;
	}

	// announce 2
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 2
	// create_config
	create_config = SCR::Read (.sysconfig.mail.MAIL_CREATE_CONFIG) == "yes";

	// connection_type:
	boolean nc = false;
	boolean ex = false;
	boolean service = false;
	if (mta == `sendmail)
	{
	    // the service must be always running
	    nc = SCR::Read (.sysconfig.sendmail.SENDMAIL_NOCANONIFY) == "yes";
	    ex = SCR::Read (.sysconfig.sendmail.SENDMAIL_EXPENSIVE) == "yes";
	    if (nc)
	    {
		connection_type = (ex)? `dialup : `none;
	    }
	    else
	    {
		connection_type = `permanent;
	    }
	}
	else if (mta == `postfix)
	{
//	    nc = SCR::Read (.sysconfig.postfix.POSTFIX_NODNS) == "yes";
	    ex = SCR::Read (.sysconfig.postfix.POSTFIX_DIALUP) == "yes";
	    service = Runlevel::ServiceEnabled ("postfix");
	    if (service)
	    {
		connection_type = (ex)? `dialup : `permanent;
	    }
	    else
	    {
		connection_type = `none;
	    }
	}
	else
	{
	    return false;
	}

	// amavis
	string amavis_pkg = (mta == `sendmail)? "amavis-sendmail":"amavis-postfix";
	amavis_allowed = SCR::Read (.targetpkg.installed, amavis_pkg) ||
	    AvailableForInstallation (amavis_pkg);
	use_amavis = amavis_allowed && (SCR::Read (.sysconfig.amavis.USE_AMAVIS) == "yes");

	// local_domains
	string ld_s = "";
	if (mta == `sendmail)
	{
	    ld_s = SCR::Read (.sysconfig.sendmail.SENDMAIL_LOCALHOST);
	}
	else if (mta == `postfix)
	{
	    ld_s = SCR::Read (.sysconfig.postfix.POSTFIX_LOCALDOMAINS);
	}
	else
	{
	    return false;
	}
	local_domains = filter (`s, splitstring (ld_s, " ,;"), ``(s != ""));

	// outgoing_mail_server
	if (mta == `sendmail)
	{
	    outgoing_mail_server = SCR::Read (.sysconfig.sendmail.SENDMAIL_SMARTHOST);
	}
	else if (mta == `postfix)
	{
	    outgoing_mail_server = SCR::Read (.sysconfig.postfix.POSTFIX_RELAYHOST);
	}
	else
	{
	    return false;
	}

	// announce 3
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 3
	// from_header
	from_header = SCR::Read (.sysconfig.mail.FROM_HEADER);
	// handle nonexistent file
	if (from_header == nil)
	{
	    from_header = "";
	}

	// masquerade_other_domains
	string mod_s = "";
	if (mta == `sendmail)
	{
	    mod_s = SCR::Read (.sysconfig.sendmail.MASQUERADE_DOMAINS);
	}
	else if (mta == `postfix)
	{
	    mod_s = SCR::Read (.sysconfig.postfix.POSTFIX_MASQUERADE_DOMAIN);
	}
	else
	{
	    return false;
	}
	masquerade_other_domains = filter (`s, splitstring (mod_s, " ,;"), ``(s != ""));

	// masquerade_users
	list(map) mu_raw = [];
	if (mta == `sendmail)
	{
	    mu_raw = SCR::Read (.mail.sendmail.generics.table);
	}
	else if (mta == `postfix)
	{
	    mu_raw = SCR::Read (.mail.postfix.sendercanonical.table);
	}
	else
	{
	    return false;
	}
	masquerade_users = maplist (map e, mu_raw,
				    ``($[
					   "comment"	: e["comment"]: "",
					   "user"	: e["key"]: "",
					   "address"	: e["value"]: "",
					   ]));

	// announce 4
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 4
	fetchmail = SCR::Read (.mail.fetchmail.accounts);
	if (fetchmail == nil)
	{
	    // Translators: error message,
	    // %1 is a file name, %2 is a long file name
	    Report::Error (sformat(_("Error reading file %1. The file must have
a fixed format to be readable by YaST2.  For details, see
%2"),
			 "/etc/fetchmailrc",
			 "/usr/share/doc/packages/yast2-config-mail/fetchmailrc.txt"));
	    return false;
	}
	//TODO what to do with a difficult syntax etc?

	// announce 5
	Progress::NextStage ();
	if (eval (abort))
	{
	    return false;
	}
	// read 5
	merge_aliases = false;

	// aliases
	list(map) a_raw = [];
	if (mta == `sendmail)
	{
	    a_raw = SCR::Read (.mail.sendmail.aliases.table);
	}
	else if (mta == `postfix)
	{
	    a_raw = SCR::Read (.mail.postfix.aliases.table);
	}
	else
	{
	    return false;
	}
	aliases =  maplist (map e, a_raw,
			    ``($[
				   "comment"		: e["comment"]: "",
				   "alias"		: e["key"]: "",
				   "destinations"	: e["value"]: "",
				   ]));

	// virtual_users
	list(map) v_raw = [];
	if (mta == `sendmail)
	{
	    v_raw = SCR::Read (.mail.sendmail.virtuser.table);
	}
	else if (mta == `postfix)
	{
	    v_raw = SCR::Read (.mail.postfix.virtual.table);
	}
	else
	{
	    return false;
	}
	virtual_users =  maplist (map e, v_raw,
				  ``($[
					 "comment"	: e["comment"]: "",
					 "alias"	: e["key"]: "",
					 "destinations"	: e["value"]: "",
					 ]));

	// complete
	Progress::NextStage ();
	return true;
    }

    // document and TEST
    /**
     * Merges mail tables, which are order-preserving maps.
     * First are the entries of the old map, with values updated
     * from the new one, then the rest of the new map.
     * @param new	new table
     * @param old	old table
     * @return		merged table
     */
    define list(map) mergeTables (list(map) new, list(map) old) ``{
	// make a true map
	map new_m = listmap (map e, new,
			     ``([
				    e["key"]:"",
				    [ e["comment"]:"", e["value"]:"" ]
				    ]));
	// update old values
	list(map) replaced = maplist (map e, old, ``{
	    string k = e["key"]:"";
	    list cv = new_m[k]:[];
	    if (size (cv) > 0)
	    {
		new_m[k] = []; // ok, newly constructed
		return $["key": k, "comment": cv[0]:"", "value": cv[1]:""];
	    }
	    else
	    {
		return $["key": k, "comment": e["comment"]:"", "value": e["value"]:""];
	    }
	});
	// remove already updated values
	list(map) filtered = filter (map e, new, ``(
					 size (new_m[ e["key"]:"" ]:[]) > 0)
	    );
	return flatten ([replaced, filtered]);
    }

    /**
     * Update the SCR according to mail settings
     * @param abort A block that can be called by Write to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @param writeonly	If true, don't run SuSEconfig or restart the services.
     *			Autoinstall uses this to do in all in one place.
     * @return True on success
     */
    global define boolean Write (block abort, boolean writeonly) ``{
	list stages = [
	    // Translators: progress label
	    [ _("Writing general settings"), ``(WriteGeneral ())],
	    ];
	if (connection_type != `none)
	{
	    // Translators: progress label
	    stages = add (stages, [ _("Writing masquerading settings"), ``(WriteMasquerading ()) ]);
	    // Translators: progress label
	    stages = add (stages, [ _("Writing alias tables"), ``(WriteAliases ()) ]);
	    if (connection_type == `dialup)
	    {
		// Translators: progress label
		stages = add (stages, [ _("Writing downloading settings"), ``(WriteDownloading ()) ]);
	    }
	}
	// Translators: progress label
	stages = add (stages, [ _("Finishing writing configuration files"), ``(WriteFlush ()) ]);
	// autoinstallation does it all together later
	if (! writeonly)
	{
	    // Translators: progress label
	    stages = add (stages, [ _("Running SuSEconfig"), ``(WriteSuSEconfig ()) ]);

	    // Translators: progress label
	    stages = add (stages, [ _("Restarting services"), ``(WriteServices ()) ]);
	}

	// Translators: dialog caption
	string caption = _("Saving mail configuration");
	// We do not set help text here, because it was set outside
	Progress::New (caption, " ", 0, maplist (list e, stages, ``(e[0]:"")), [], "");

	foreach (list e, stages, ``{
	    Progress::NextStage ();
	    if (eval (abort))
	    {
		return false;
	    }

	    term f = e[1]:``(false);
	    if (! eval (f))
	    {
		return false;
	    }
	});

	// complete
	Progress::NextStage ();
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteGeneral () ``{
	// create_config
	// if the user wanted it false, we did not proceed
	SCR::Write (.sysconfig.mail.MAIL_CREATE_CONFIG, "yes");

	// connection_type
	if (mta == `sendmail)
	{
	    path nc = .sysconfig.sendmail.SENDMAIL_NOCANONIFY;
	    path ex = .sysconfig.sendmail.SENDMAIL_EXPENSIVE;
	    if (connection_type == `permanent)
	    {
		SCR::Write (nc, "no");
		SCR::Write (ex, "no");
	    }
	    else if (connection_type == `dialup)
	    {
		SCR::Write (nc, "yes");
		SCR::Write (ex, "yes");
	    }
	    else if (connection_type == `none)
	    {
		SCR::Write (nc, "yes");
		SCR::Write (ex, "no");
	    }
	    else
	    {
		y2internal("Unrecognized connection_type: %1", connection_type);
		return false;
	    }
	    Runlevel::ServiceAdjust ("sendmail", "enable");
	}
	else if (mta == `postfix)
	{
	    path nd = .sysconfig.postfix.POSTFIX_NODNS;
	    path di = .sysconfig.postfix.POSTFIX_DIALUP;
	    if (connection_type == `permanent)
	    {
		SCR::Write (nd, "no");
		SCR::Write (di, "no");
		Runlevel::ServiceAdjust ("postfix", "enable");
	    }
	    else if (connection_type == `dialup)
	    {
		SCR::Write (nd, "yes");
		SCR::Write (di, "yes");
		Runlevel::ServiceAdjust ("postfix", "enable");
	    }
	    else if (connection_type == `none)
	    {
		SCR::Write (nd, "yes");
		SCR::Write (di, "no");
		Runlevel::ServiceAdjust ("postfix", "disable");
	    }
	    else
	    {
		y2internal("Unrecognized connection_type: %1", connection_type);
		return false;
	    }
	}
	else
	{
	    return false;
	}

	// amavis
	SCR::Write (.sysconfig.amavis.USE_AMAVIS, use_amavis? "yes":"no");

	// SENDMAIL_ARGS
	// by default they contain -q30m, not good for dial-up
	// SENDMAIL_CLIENT_ARGS must contain -q... or it will not run!
	if (mta == `sendmail)
	{
	    string default_permanent = "-L sendmail -Am -bd -q30m -om";
	    string default_dialup = "-L sendmail -Am -bd -om";
	    string args = SCR::Read (.sysconfig.sendmail.SENDMAIL_ARGS);

	    if (connection_type == `permanent && args == default_dialup)
	    {
		SCR::Write (.sysconfig.sendmail.SENDMAIL_ARGS, default_permanent);
	    }
	    else if (connection_type == `dialup &&
		     // if empty, sendmail init-script uses the default
		     (args == default_permanent || args == ""))
	    {
		SCR::Write (.sysconfig.sendmail.SENDMAIL_ARGS, default_dialup);
	    }
	}

	// local_domains
	if (mta == `sendmail)
	{
	    string ld_s = mergestring (local_domains, " ");
	    SCR::Write (.sysconfig.sendmail.SENDMAIL_LOCALHOST, ld_s);
	}
	else if (mta == `postfix)
	{
	    string ld_s = mergestring (local_domains, ","); // noted in #12672
	    SCR::Write (.sysconfig.postfix.POSTFIX_LOCALDOMAINS, ld_s);
	}
	else
	{
	    return false;
	}

	// outgoing_mail_server
	if (mta == `sendmail)
	{
	    SCR::Write (.sysconfig.sendmail.SENDMAIL_SMARTHOST, outgoing_mail_server);
	}
	else if (mta == `postfix)
	{
	    SCR::Write (.sysconfig.postfix.POSTFIX_RELAYHOST, outgoing_mail_server);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteMasquerading () ``{
	// from_header
	SCR::Write (.sysconfig.mail.FROM_HEADER, from_header);
	// masquerade_other_domains
	if (mta == `sendmail)
	{
	    string mod = mergestring (masquerade_other_domains, " ");
	    SCR::Write (.sysconfig.sendmail.MASQUERADE_DOMAINS, mod);
	}
	else if (mta == `postfix)
	{
	    string mod = mergestring (masquerade_other_domains, ",");
	    SCR::Write (.sysconfig.postfix.POSTFIX_MASQUERADE_DOMAIN, mod);
	}
	else
	{
	    return false;
	}

	// masquerade_users
	list(map) mu_raw = maplist (map e, masquerade_users,
				    ``($[
					   "comment"	: e["comment"]:"",
					   // TODO check that nonempty
					   "key"	: e["user"]:"",
					   "value"	: e["address"]:"",
					   ]));
	if (mta == `sendmail)
	{
	    SCR::Write (.mail.sendmail.generics.table, mu_raw);
	}
	else if (mta == `postfix)
	{
	    SCR::Write (.mail.postfix.sendercanonical.table, mu_raw);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteDownloading () ``{
	// fetchmail
	// TODO ?other settings: autofetch? at device up?
	SCR::Write (.mail.fetchmail.accounts, fetchmail);
	if (! SCR::Write (.mail.fetchmail, nil))
	{
	    // Translators: error message
	    Report::Error (_("Error writing the fetchmail configuration."));
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteAliases () ``{
	// aliases
	path alias_path = nil;
	if (mta == `sendmail)
	{
	    alias_path = .mail.sendmail.aliases.table;
	}
	else if (mta == `postfix)
	{
	    alias_path = .mail.postfix.aliases.table;
	}
	else
	{
	    return false;
	}
	list(map) a_raw = maplist (map e, aliases,
				   ``($[
					  "comment"	: e["comment"]:"",
					  "key"		: e["alias"]:"",
					  "value"	: e["destinations"]:"",
					  ]));
	if (merge_aliases)
	{
	    a_raw = mergeTables (a_raw, SCR::Read (alias_path));
	}
	SCR::Write (alias_path, a_raw);


	// virtual_users
	list(map) v_raw = maplist (map e, virtual_users,
				   ``($[
					  "comment"	: e["comment"]:"",
					  "key"		: e["alias"]:"",
					  "value"	: e["destinations"]:"",
					  ]));
	if (mta == `sendmail)
	{
	    SCR::Write (.mail.sendmail.virtuser.table, v_raw);
	}
	else if (mta == `postfix)
	{
	    SCR::Write (.mail.postfix.virtual.table, v_raw);
	}
	else
	{
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteFlush () ``{
	//flush the agents
	if (!SCR::Write (.sysconfig.mail, nil))
	{
	    // Translators: error message
	    Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/mail"));
	    return false;
	}
	if (!SCR::Write (.sysconfig.amavis, nil))
	{
	    // Translators: error message
	    Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/amavis"));
	    return false;
	}
	list(path) tables = nil;
	if (mta == `sendmail)
	{
	    if (!SCR::Write (.sysconfig.sendmail, nil))
	    {
		// Translators: error message
		Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/sendmail"));
		return false;
	    }
	    tables = [
		.mail.sendmail.generics,
		.mail.sendmail.aliases,
		.mail.sendmail.virtuser,
		];
	}
	else if (mta == `postfix)
	{
	    if (!SCR::Write (.sysconfig.postfix, nil))
	    {
		// Translators: error message
		Report::Error (sformat (_("Error writing file %1"), "/etc/sysconfig/postfix"));
		return false;
	    }
	    tables = [
		.mail.postfix.sendercanonical,
		.mail.postfix.aliases,
		.mail.postfix.virtual,
		];
	}
	else
	{
	    return false;
	}

	foreach (path p, tables, ``{
	    if (!SCR::Write (p, nil))
	    {
		string filename = SCR::Read (p + topath (".meta.filename"));
		// Translators: error message
		Report::Error (sformat (_("Error writing file %1"), filename));
		return false;
	    }
	});
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteSuSEconfig () ``{
	//run SuSEconfig with the necessary modules
	// TODO other modules using FROM_HEADER?
	integer ret = 0;
	if (mta == `sendmail)
	{
	    ret = SCR::Execute (.target.bash, "/sbin/SuSEconfig --module sendmail");
	}
	else if (mta == `postfix)
	{
	    ret = SCR::Execute (.target.bash, "/sbin/SuSEconfig --module postfix");
	}
	else
	{
	    return false;
	}

	if (ret != 0)
	{
	    // Translators: error message
	    Report::Error (_("Error running SuSEconfig."));
	    return false;
	}
	return true;
    }

    /**
     * Part of Write.
     * @return success
     */
    define boolean WriteServices () ``{
	string service = "";
	if (mta == `sendmail)
	{
	    service = "sendmail";
	    // amavis
	    Runlevel::RunInitScript ("amavis", "stop");
	    if (use_amavis)
	    {
		if (Runlevel::RunInitScript ("amavis", "start") != 0)
		{
		    // Translators: error message
		    Report::Error (sformat (_("Error starting service %1."), "amavis"));
		    return false;
		}
		Runlevel::ServiceAdjust ("amavis", "enable");
	    }
	    else
	    {
		Runlevel::ServiceAdjust ("amavis", "disable");
	    }

	    if (Runlevel::RunInitScript (service, "restart") != 0)
	    {
		// Translators: error message
		Report::Error (sformat (_("Error starting service %1."), service));
		return false;
	    }
	}
	else if (mta == `postfix)
	{
	    // There's no separate amavis init script.
	    service = "postfix";
	    Runlevel::RunInitScript (service, "stop");
	    if (connection_type != `none)
	    {
		if (Runlevel::RunInitScript (service, "start") != 0)
		{
		    // Translators: error message
		    Report::Error (sformat (_("Error starting service %1."), service));
		    return false;
		}
	    }
	}
	else
	{
	    return false;
	}

	// ServiceAdjust enable/disable is done in WriteGeneral

	return true;
    }

    /**
     * Get all mail settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return True on success
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    return true;
	}

	boolean missing = false;
	foreach (`k, ["mta", "connection_type",  "local_domains", "outgoing_mail_server", "from_header", "masquerade_other_domains", "masquerade_users", "fetchmail", "aliases",  "virtual_users"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}	
	Set(settings);
	return true;
    }

    
    /**
     * Set module data without validity checking as in Import()
     *
     */
    global define void Set(map settings) ``{
	y2milestone("before %1", settings);
	settings = mapmap(`k,`v, settings,``{
	    if (k == "mta" && is(v,symbol)) {
		return([k,v]);
	    } else if (k == "connection_type" && is(v,symbol)) {
		return([k,v]);
	    }
	    if (k == "mta" && v == "sendmail") {
		return(["mta", `sendmail]);
	    } else if (k == "mta" && v == "postfix") {
		return(["mta", `postfix]);
	    } else if (k == "mta") {
		return(["mta", `other]);
	    } else if (k == "connection_type" && v == "permanent") {
		return(["connection_type", `permanent]);
	    } else if (k == "connection_type" && v == "dialup") {
		return(["connection_type", `dialup]);
	    } else  if (k == "connection_type") {
		return(["connection_type", `none]);
	    } else {
		return ([k,v]);
	    }
	    

	});

	mta = settings["mta"]: `other;
	connection_type = settings["connection_type"]: `none;
	use_amavis = settings["use_amavis"]: false;
	local_domains = settings["local_domains"]: [];
	outgoing_mail_server = settings["outgoing_mail_server"]: "";
	from_header = settings["from_header"]: "";
	masquerade_other_domains = settings["masquerade_other_domains"]: [];
	masquerade_users = settings["masquerade_users"]: [];
	fetchmail = settings["fetchmail"]: [];
	aliases = settings["aliases"]: [];
	merge_aliases = settings["merge_aliases"]: false;
	virtual_users = settings["virtual_users"]: [];
	y2milestone("after %1", settings);
	return;
    }

    
    /**
     * Dump the mail settings to a single map
     * (For use by autoinstallation.)
     * @return Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	return $[
	    "mta": mta,
	    "connection_type": connection_type,
	    "use_amavis": use_amavis,
	    "local_domains": local_domains,
	    "outgoing_mail_server": outgoing_mail_server,
	    "from_header": from_header,
	    "masquerade_other_domains": masquerade_other_domains,
	    "masquerade_users": masquerade_users,
	    "fetchmail": fetchmail,
	    "aliases": aliases,
	    "merge_aliases": merge_aliases,
	    "virtual_users": virtual_users,
	    ];
    }

    /**
     * Summary
     * @return string with summary of configuration
     */
    global define string Summary ()
	``{
	
	string agent = "";
	if (mta == `sendmail)
	     agent = "sendmail";
	else if (mta == `postfix)
	    agent = "postfix";
	else
	    agent = "other";

	
	string con_type = "";
	if (connection_type == `permanent)
	    con_type = "Permanent";
	else if (connection_type == `dialup)
	    con_type = "Dialup";
	else
	    con_type = "None";	
	
	string summary = "";
	summary = Summary::AddHeader(summary, _("MTA"));
	summary = Summary::AddLine(summary, agent);
	summary = Summary::AddHeader(summary, _("Connection Type"));
	summary = Summary::AddLine(summary,con_type );

	summary = Summary::AddHeader(summary, _("Outgoing Mail Server"));
	summary = Summary::AddLine(summary, (outgoing_mail_server != "") ? outgoing_mail_server : Summary::NotConfigured ());

	summary = Summary::AddHeader(summary, _("From Header"));
	summary = Summary::AddLine(summary, (from_header != "") ? from_header : Summary::NotConfigured ());

	
	summary = summary + ListItem( _("Local Domains"),local_domains);
	summary = summary + ListItem( _("Masquerade other Domains"),masquerade_other_domains);
	summary = summary + ListItem( _("Masquerade Users"),masquerade_users);
	summary = summary + ListItem( _("Fetchmail"),fetchmail);
	summary = summary + ListItem( _("Aliases"),aliases);
	summary = summary + ListItem( _("Virtual Users"),virtual_users);
	summary = Summary::AddHeader(summary, _("Use AMaViS"));
	summary = Summary::AddLine(summary, (use_amavis) ? _("Yes") : Summary::NotConfigured ());	
	return summary;
    }

    
    define string ListItem(string title, any value) ``{
	string summary = "";
	summary = Summary::AddHeader(summary, title);
	if (is(value,list) && size(value)>0) {
	    summary = Summary::OpenList(summary);
	    foreach (`d, value, ``{
		string entry = "";
		if (is(d,map) || is (d,list))
		    entry = sformat("%1 Entries configured", size(value));
		else
		    entry = d;
		
		summary = Summary::AddListItem(summary, entry);		
	    });
	    summary = Summary::CloseList(summary);
	} else {
	    summary = Summary::AddLine(summary,Summary::NotConfigured ());
	}
	return summary;
    }
}
